<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>ttg: ttg</title>
    <!--BEGIN PROJECT_ICON-->
    <link rel="icon" href="$projecticon" type="image/x-icon" />
    <!--END PROJECT_ICON-->
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <!--BEGIN COPY_CLIPBOARD-->
    <script type="text/javascript" src="clipboard.js"></script>
    <!--END COPY_CLIPBOARD-->
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init();
        DoxygenAwesomeParagraphLink.init();
    </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                <tr id="projectrow">
                    <td id="projectalign">
                        <div id="projectname">ttg<span id="projectnumber">&#160;1.0.0</span>
                        </div>
                        <div id="projectbrief">Template Task Graph (TTG): flowgraph-based programming model for high-performance distributed-memory algorithms</div>
                    </td>
                </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ttg </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__r_e_a_d_m_e"></a> <img src="https://github.com/TESSEorg/ttg/actions/workflows/cmake.yml/badge.svg" alt="Build Status" style="pointer-events: none;" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md35"></a>
TTG</h1>
<p>This is the C++ API for the Template Task Graph (TTG) programming model for flowgraph-based composition of high-performance algorithms executable on distributed heterogeneous computer platforms. The TTG API abstracts out the details of the underlying task and data flow runtime; the current realization is implemented using <a href="https://github.com/m-a-d-n-e-s-s/madness">MADNESS</a> and <a href="https://bitbucket.org/icldistcomp/parsec.git">PaRSEC</a> runtimes as backends.</p>
<h1><a class="anchor" id="autotoc_md36"></a>
Why TTG?</h1>
<p>TTG might be for you if you want fine-grained parallel execution of complex (especially, data-dependent) algorithms on distributed-memory heterogeneous machines, for these reasons:</p>
<ul>
<li>programming models that target fine-grained parallelism, like native language tools (threads, async) and programming models/libraries (OpenMP, TaskFlow, Cilk, etc.) deal only with control flow, and thus are poorly suited for dealing with data-dependent execution</li>
<li>such models do not deal with distributed memory anyway</li>
<li>and specialized runtimes like StarPU, PaRSEC, MADNESS, HPX, UPC++, etc., are still relatively low-level abstractions for expressing complex data-dependent task flows across modern distributed heterogeneous machines.</li>
</ul>
<p>The development of TTG was motivated by <em>irregular</em> scientific applications like adaptive multiresolution numerical calculus and data-sparse tensor algebra which have lacked tools to keep up with the evolution of HPC platforms, especially toward heterogeneity. But TTG is far more widely applicable than that; it is a general-purpose programming model.</p>
<h1><a class="anchor" id="autotoc_md37"></a>
Installation</h1>
<ul>
<li>To try out TTG in a Docker container, install Docker, then execute <code>bin/docker-build.sh</code> and follow instructions in <code>bin/docker.md</code>;</li>
<li>See <a href="https://github.com/TESSEorg/ttg/blob/master/INSTALL.md">INSTALL.md</a> to learn how to build and install TTG.</li>
</ul>
<h1><a class="anchor" id="autotoc_md38"></a>
A Short Intro to TTG</h1>
<h2><a class="anchor" id="autotoc_md39"></a>
TL;DR: A "Hello, World" TTG Program</h2>
<p><code><a class="el" href="helloworld_8cpp.html">helloworld.cpp</a></code></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ttg.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="distributed_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a19c06079af2c21be154b525ff21028d1">ttg::initialize</a>(argc, argv);</div>
<div class="line">  <span class="comment">// a simple template task (TT)</span></div>
<div class="line">  <span class="keyword">auto</span> tt = ttg::make_tt([]() { std::cout &lt;&lt; <span class="stringliteral">&quot;Hello, World!\n&quot;</span>; });</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// single TT is also a TT graph (=TTG); signal that we are done constructing the TTG</span></div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#ade4672895f07e88909dab1644c69e60a">ttg::make_graph_executable</a>(tt);</div>
<div class="line">  <span class="comment">// start executing any available tasks</span></div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a>();</div>
<div class="line">  <span class="comment">// create task to kickstart computation</span></div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_function" href="namespacettg.html#a5829b255a41f2e47fa0e27bb5c791824">ttg::get_default_world</a>().rank() == 0) tt-&gt;invoke();</div>
<div class="line">  <span class="comment">// wait for completion</span></div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a>();</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a96780ef3c553a2f45aa7ea881bdb6490">ttg::finalize</a>();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="adistributed_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="distributed_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdef"><b>Definition</b> <a href="distributed_8cc_source.html#l00032">distributed.cc:32</a></div></div>
<div class="ttc" id="anamespacettg_html_a1261c57f70c978771f64af07d7f7d7cd"><div class="ttname"><a href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a></div><div class="ttdeci">void execute(ttg::World world)</div><div class="ttdoc">Starts the execution in the given execution context.</div><div class="ttdef"><b>Definition</b> <a href="run_8h_source.html#l00116">run.h:116</a></div></div>
<div class="ttc" id="anamespacettg_html_a19c06079af2c21be154b525ff21028d1"><div class="ttname"><a href="namespacettg.html#a19c06079af2c21be154b525ff21028d1">ttg::initialize</a></div><div class="ttdeci">void initialize(int argc, char **argv, int num_threads=-1, RestOfArgs &amp;&amp;...)</div></div>
<div class="ttc" id="anamespacettg_html_a5829b255a41f2e47fa0e27bb5c791824"><div class="ttname"><a href="namespacettg.html#a5829b255a41f2e47fa0e27bb5c791824">ttg::get_default_world</a></div><div class="ttdeci">ttg::World &amp; get_default_world()</div><div class="ttdef"><b>Definition</b> <a href="world_8h_source.html#l00081">world.h:81</a></div></div>
<div class="ttc" id="anamespacettg_html_a807bf42719a82b1539603d477aa2a3fd"><div class="ttname"><a href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a></div><div class="ttdeci">void fence(ttg::World world)</div><div class="ttdoc">Returns when all tasks associated with the given execution context have finished on all ranks.</div><div class="ttdef"><b>Definition</b> <a href="run_8h_source.html#l00123">run.h:123</a></div></div>
<div class="ttc" id="anamespacettg_html_a96780ef3c553a2f45aa7ea881bdb6490"><div class="ttname"><a href="namespacettg.html#a96780ef3c553a2f45aa7ea881bdb6490">ttg::finalize</a></div><div class="ttdeci">void finalize()</div><div class="ttdoc">Finalizes the TTG runtime.</div><div class="ttdef"><b>Definition</b> <a href="func_8h_source.html#l00590">func.h:590</a></div></div>
<div class="ttc" id="anamespacettg_html_ade4672895f07e88909dab1644c69e60a"><div class="ttname"><a href="namespacettg.html#ade4672895f07e88909dab1644c69e60a">ttg::make_graph_executable</a></div><div class="ttdeci">std::enable_if_t&lt;(std::is_convertible_v&lt; decltype(*(std::declval&lt; TTBasePtrs &gt;())), TTBase &amp; &gt; &amp;&amp;...), bool &gt; make_graph_executable(TTBasePtrs &amp;&amp;...tts)</div><div class="ttdoc">Make the TTG tts executable. Applies.</div><div class="ttdef"><b>Definition</b> <a href="func_8h_source.html#l00081">func.h:81</a></div></div>
</div><!-- fragment --><p><code>CMakeLists.txt</code></p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.19)</div>
<div class="line">project(TTG-HW CXX)</div>
<div class="line"> </div>
<div class="line">find_package(ttg QUIET) # check if TTG is already available</div>
<div class="line">if (NOT TARGET ttg-parsec) # else build from source</div>
<div class="line">  include(FetchContent)</div>
<div class="line">  FetchContent_Declare(ttg GIT_REPOSITORY https://github.com/TESSEorg/ttg.git)</div>
<div class="line">  FetchContent_MakeAvailable( ttg )</div>
<div class="line">endif()</div>
<div class="line"> </div>
<div class="line">add_executable(helloworld-parsec helloworld.cpp)</div>
<div class="line">target_link_libraries(hw-parsec PRIVATE ttg-parsec)</div>
<div class="line">target_compile_definitions(hw-parsec PRIVATE TTG_USE_PARSEC=1)</div>
</div><!-- fragment --><p>Configure + build:</p>
<div class="fragment"><div class="line">&gt; cmake -S . -B build &amp;&amp; cmake --build build --target helloworld-parsec</div>
</div><!-- fragment --><p>The complete example, including the CMake build harness using a slightly easier way to build the executable (using <code>add_ttg_executable</code> CMake macro), can be found in <a href="https://github.com/TESSEorg/ttg/tree/master/doc/dox/dev/devsamp/helloworld">dox examples</a>.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
"Hello, World!" Walkthrough</h2>
<p>Although it does not involve any useful flow of computation and/or data, the above "Hello, World!" TTG program introduces several key TTG concepts and illustrates what you need to do to write a complete TTG program. So let's walk through it.</p>
<h3><a class="anchor" id="autotoc_md41"></a>
Programming Model</h3>
<p>The basic model of computation is built around a Template Task Graph (TTG). A TTG consists of one or more connected Template Task (TT) objects. Each message that travels between TTs consist of a (potentially void) task ID and (optional) datum. A TT creates a task for a given task ID when all of its input terminals have received a message with that task ID. The task body can send data to zero or more of the output terminals defined for the corresponding TT.</p>
<p>Thus, task creation is a byproduct of messages traveling through one or more TTGs. What makes the model powerful is the ability to encode large DAGs of tasks compactly.</p>
<p>Before proceeding further, let's refine the few concepts used to define the programming model above:</p>
<ul>
<li><code>TaskId</code> (aka <code>Key</code>): A unique identifier for each task. It must be <em>perfectly</em> hashable.</li>
<li><code>Terminal</code>: A port for receiving (input) and sending (output) messages. Each message consists of a (potentially void) <code>TaskId</code> and an (optional) datum. Terminals are strongly-typed. An {in,out}put terminal can be connected to one or more {out,in}put terminal (as long as the <code>TaskId</code> and datum types match). Input terminals are programmable (e.g., incoming messages can be optionally reduced).</li>
<li><code>TemplateTask</code> (aka <code>TT</code>): This is a <em>template</em> for creating tasks. The task template creates a task associated with a given <code>TaskId</code> when every input terminal received messages for the given <code>TaskId</code>.</li>
<li><code>Edge</code>: A connection between an input terminal and an output terminal. An <code>Edge</code> denotes a 1-to-1 connection and exists to be able to think of TTGs as graphs ("data flows between TTs' terminals via Edges"); do not confuse with the TTG C++ class <code>Edge</code> which behaves like a hyperedge by composing 1-to-many and many-to-1 connections between terminals.</li>
</ul>
<p>Due to its simplicity only one template task appears in the "Hello, World!" program.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
Structure of a Minimal TTG Program</h2>
<p>Every TTG program must:</p>
<ul>
<li>select the TTG backend,</li>
<li>initialize the TTG runtime,</li>
<li>construct a TTG by declaring its constituent nodes,</li>
<li>make TTG executable and kickstart the execution by sending a control or data message to the TTG,</li>
<li>shut down the runtime</li>
</ul>
<p>Let's go over each of these steps using the "Hello, World!" example. The complete example, including the CMake build harness, can be found in <a href="https://github.com/TESSEorg/ttg/tree/master/doc/dox/dev/devsamp/fibonacci">dox examples</a>.</p>
<h3><a class="anchor" id="autotoc_md43"></a>
Select the TTG Backend</h3>
<p>The TTG C++ implementation is currently supported by 2 backends providing task scheduling, data transfer, and resource management. While it is possible to use a specific TTG backend explicitly, by using the appropriate namespaces, it is recommended to write backend-neutral programs that can be specialized to a particular backend in of the two ways.</p>
<ol type="1">
<li>By defining one (and only one) of the following macros, via the command-line argument to the compiler (recommended) or as an explicit <code>#define</code> statement in the source code:<ul>
<li><code>TTG_USE_PARSEC</code>: selects the PaRSEC backend as the default;</li>
<li><p class="startli"><code>TTG_USE_MADNESS</code>: selects the MADNESS backend as the default (expert-use only).</p>
<p class="startli">Following the definition of this macro it is safe to include the top-level TTG header file:</p>
<p class="startli"><code>cpp #include &lt;ttg.h&gt; </code></p>
</li>
</ul>
</li>
<li><p class="startli">By including the corresponding backend-specific header directly:</p><ul>
<li><p class="startli">to use PaRSEC backend only, add:</p>
<p class="startli"><code>cpp #include &lt;<a class="el" href="ttg_2parsec_2ttg_8h.html">ttg/parsec/ttg.h</a>&gt; </code></p>
</li>
<li><p class="startli">to use the MADNESS backend only, add:</p>
<p class="startli"><code>cpp #include &lt;<a class="el" href="ttg_2madness_2ttg_8h.html">ttg/madness/ttg.h</a>&gt; </code></p>
</li>
</ul>
<p class="startli">This approach does not require inclusion of the top-level TTG header or definition of a backend selection macro.</p>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md44"></a>
Initialize</h3>
<p>To initialize the TTG runtime invoke <code>ttg::initialize(argc, argv)</code>. There are several overloads of this function that also accept other optional parameters, such as the number of threads in the main thread pool, the MPI communicator for execution, etc.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Create a TTG</h2>
<p>To make a TTG, create and connect one or more TTs. The simplest TTG consists of a single TT as in the "Hello, World!" example.</p>
<p>Since the TT in the "Hello, World!" example generates a single task, the task ID can be omitted (its type is <code>void</code>). This task also does not take or produce any data. The easiest way to make such a TT is by wrapping a callable (e.g., a lambda) with <code>ttg::make_tt</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> tt = ttg::make_tt([]() { std::cout &lt;&lt; <span class="stringliteral">&quot;Hello, World!\n&quot;</span>; });</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md46"></a>
Execute TTG</h2>
<p>To execute a TTG we must make it executable (this will declare the TTG program complete so no additional changes to the flowgraph are possible). To execute the TTG its root TT must receive at least one message; since in this case the task does not receive either task ID or data, the message is empty (i.e., <code>void</code>):</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacettg.html#ade4672895f07e88909dab1644c69e60a">ttg::make_graph_executable</a>(tt);</div>
<div class="line"><a class="code hl_function" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a>();</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="namespacettg.html#a5829b255a41f2e47fa0e27bb5c791824">ttg::get_default_world</a>().rank() == 0)</div>
<div class="line">    tt-&gt;invoke();</div>
</div><!-- fragment --><p><code><a class="el" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd" title="Starts the execution in the given execution context.">ttg::execute()</a></code> starts the TTG work engines and must occur before, not after, kickstarting off any computation by sending the data into the free in-terminals. The kickstart messages are generated by invoking <code>TT::invoke(taskID, values)</code>; in this case the task ID is void, and the task does not take any input data, so <code>TT::invoke()</code> receivesno parameters. Since TTG uses the Single Program Multiple Data (SPMD) execution model, every process invokes <code><a class="el" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd" title="Starts the execution in the given execution context.">ttg::execute()</a></code> when this TTG program is invoked as multiple processes, but only the first process (rank) gets to send the kickstart message since all messages in a TTG program, including the kickstart messages, must be unique.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Finalize TTG</h2>
<p>Since TTG program is executed asynchronously, we must ensure that all tasks are finished:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a>();</div>
</div><!-- fragment --><p>Before exiting <code><a class="el" href="distributed_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a></code> the TTG runtime should be finalized:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacettg.html#a96780ef3c553a2f45aa7ea881bdb6490">ttg::finalize</a>();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md48"></a>
Beyond "Hello, World!"</h2>
<p>Since "Hello, World!" consists of a single task it does not demonstrate either how to control scheduling of multiple tasks or enable data flow between tasks. Let's use the computation of the <code>N</code>th Fibonacci number as a simple example of a recursive task-based computation that is often used (<a href="https://www.openmp.org/wp-content/uploads/openmp-examples-5.1.pdf">OpenMP</a>, <a href="https://github.com/oneapi-src/oneTBB/blob/master/examples/test_all/fibonacci/fibonacci.cpp">TBB</a>, <a href="https://legion.stanford.edu/tutorial/tasks_and_futures.html">Legion</a>, <a href="https://cilk.mit.edu/programming/">Cilk</a>) to illustrate basic features of task-based programming models. Although the example lacks opportunity for parallelism, the point here is not performance but its simplicity.</p>
<h3><a class="anchor" id="autotoc_md49"></a>
Example: &lt;tt&gt;N&lt;/tt&gt;th Fibonacci Number</h3>
<p>This example illustrates how to compute a particular element of the Fibonacci sequence defined by recurrence $F_N = F_{N-1} + F_{N-2}, F_0=0, F_1=1$.</p>
<p><code>nth-fibonacci.cpp</code></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ttg.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="distributed_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a19c06079af2c21be154b525ff21028d1">ttg::initialize</a>(argc, argv);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> int64_t N = 20; <span class="comment">// want to compute fib(20)</span></div>
<div class="line">  <span class="comment">// edges used for recursion</span></div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;int64_t, int64_t&gt;</a> f2f_nm1, f2f_nm2;</div>
<div class="line">  <span class="comment">// edge to the task printing the output</span></div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;void, int64_t&gt;</a> f2p;</div>
<div class="line">  <span class="keyword">auto</span> fib = ttg::make_tt(</div>
<div class="line">      [=](int64_t n, int64_t F_nm1, int64_t F_nm2) {</div>
<div class="line">        <span class="keyword">auto</span> F_n = F_nm1 + F_nm2;</div>
<div class="line">        <span class="keywordflow">if</span> (n &lt; N) {</div>
<div class="line">          <span class="comment">// recursion: send result to first input and</span></div>
<div class="line">          <span class="comment">//            prior result to second input of Fib(n+1)</span></div>
<div class="line">          ttg::send&lt;0&gt;(n + 1, F_n);</div>
<div class="line">          ttg::send&lt;1&gt;(n + 1, F_nm1);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="comment">// send to print task below</span></div>
<div class="line">          ttg::sendv&lt;2&gt;(F_n);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line">      <span class="comment">// input edges: first input, second input</span></div>
<div class="line">      <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(f2f_nm1, f2f_nm2),</div>
<div class="line">      <span class="comment">// output edges: to first input, to second input, to print task</span></div>
<div class="line">      <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(f2f_nm1, f2f_nm2, f2p),</div>
<div class="line">      <span class="comment">// name of the task</span></div>
<div class="line">      <span class="stringliteral">&quot;fib&quot;</span>);</div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">print</a> = ttg::make_tt([](int64_t F_N) { std::cout &lt;&lt; N &lt;&lt; <span class="stringliteral">&quot;th Fibonacci number is &quot;</span> &lt;&lt; F_N &lt;&lt; std::endl; },</div>
<div class="line">                            <span class="comment">// input from fib</span></div>
<div class="line">                            <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(f2p),</div>
<div class="line">                            <span class="comment">// no outputs</span></div>
<div class="line">                            <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(),</div>
<div class="line">                            <span class="stringliteral">&quot;print&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#ade4672895f07e88909dab1644c69e60a">ttg::make_graph_executable</a>(fib);</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a>();</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_function" href="namespacettg.html#a5829b255a41f2e47fa0e27bb5c791824">ttg::get_default_world</a>().<a class="code hl_function" href="namespacettg.html#ac0ad1dd3b87329e4acf9774df6dc8473">rank</a>() == 0) fib-&gt;invoke(2, std::make_tuple(1, 0));</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a>();</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a96780ef3c553a2f45aa7ea881bdb6490">ttg::finalize</a>();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassttg_1_1_edge_html"><div class="ttname"><a href="classttg_1_1_edge.html">ttg::Edge</a></div><div class="ttdoc">Edge is used to connect In and Out terminals.</div><div class="ttdef"><b>Definition</b> <a href="edge_8h_source.html#l00026">edge.h:26</a></div></div>
<div class="ttc" id="anamespacettg_html_aa3510e128b769afb53720d24fa83fb97"><div class="ttname"><a href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a></div><div class="ttdeci">void print(const T &amp;t, const Ts &amp;... ts)</div><div class="ttdoc">atomically prints to std::cout a sequence of items (separated by ttg::print_separator) followed by st...</div><div class="ttdef"><b>Definition</b> <a href="print_8h_source.html#l00131">print.h:131</a></div></div>
<div class="ttc" id="anamespacettg_html_ac0ad1dd3b87329e4acf9774df6dc8473"><div class="ttname"><a href="namespacettg.html#ac0ad1dd3b87329e4acf9774df6dc8473">ttg::rank</a></div><div class="ttdeci">int rank(World world=default_execution_context())</div><div class="ttdef"><b>Definition</b> <a href="run_8h_source.html#l00127">run.h:127</a></div></div>
<div class="ttc" id="anamespacettg_html_afbabcd9802bf1bbdd302e7a612459353"><div class="ttname"><a href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a></div><div class="ttdeci">auto edges(inedgesT &amp;&amp;...args)</div><div class="ttdoc">Make a tuple of Edges to pass to.</div><div class="ttdef"><b>Definition</b> <a href="func_8h_source.html#l00148">func.h:148</a></div></div>
</div><!-- fragment --><p>The TTG consists of 2 TTs, one (<code>fib</code>) that implements the Fibonacci recurrence and another (<code>print</code>) that prints the result to <code>std::cout</code>:</p>
<ul>
<li><code>fib</code> computes $F_{n}$ from $F_{n-1}$ and $F_{n-2}$ and either sends $F_{n}$ and $F_{n-1}$ to the next ($n+1$) instance of <code>fib</code>, or, if $n=N$, sends $F_{n}$ to <code>print</code>. Thus <code>fib</code> needs 2 input terminals and 3 output terminals (for better efficiency instead of sending individual Fibonacci numbers, each over an individual edge, it is better to send a pair of Fibonacci numbers over a single edge).</li>
<li><code>print</code> receives a single unannotated datum and produces no data, so it needs a single input terminal and no output terminals.</li>
</ul>
<p>Execution of the program starts by explicitly instantiating <code>fib</code> for $n=2$. In total 20 tasks will be executed: 19 instances of <code>fib</code> with $n=2\dots20$ and the single instance of <code>print</code>.</p>
<p>Note that unlike typical task-based implementations in the literature which construct tasks <em>recursively</em>, i.e., the task for computing $F_{n}$ is created before the task computing $F_{n-1}$, the TTG implementation constructs the tasks in the order of increasing $n$. This is because parametric dataflow of TTG naturally expresses inductive (push) computation patterns rather than recursive (pull) computation patterns. However, it is easy to implement proper recursion by separating the downward flow of control (task creation, $F_{n} \to F_{n-1},F_{n-2}$) from the upward flow of data (task evaluation, $F_{n-1},F_{n-2} \to F_{n}$).</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Data-Dependent Example : Largest Fibonacci Number &lt; N</h2>
<p>To illustrate the real power of TTG let's tweak the problem slightly: instead of computing the first $N$ Fibonacci numbers let's find the largest Fibonacci number smaller than some $N$. The key difference in the latter case is that, unlike the former, the number of tasks is NOT known a priori; furthermore, to make a decision whether we need to compute next Fibonacci number we must examine the value returned by the previous task. This is an example of data-dependent tasking, where the decision which (if any) task to execute next depends on the values produced by previous tasks. The ability to compose regular as well as data-dependent task graphs is a distinguishing strength of TTG.</p>
<p>To make things even more interesting, we will demonstrate how to implement such program both for execution on CPUs as well as on accelerators (GPUs). The complete examples, including the CMake build harness, can be found in <a href="https://github.com/TESSEorg/ttg/tree/master/doc/dox/dev/devsamp/fibonacci">dox examples</a>.</p>
<h3><a class="anchor" id="autotoc_md51"></a>
The CPU Version</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ttg.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="serialization_8h.html">ttg/serialization.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_fn.html">Fn</a> {</div>
<div class="line">  int64_t <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[2];  <span class="comment">// F[0] = F_n, F[1] = F_{n-1}</span></div>
<div class="line">  <a class="code hl_function" href="struct_fn.html#a9b7f9114e90b36fc780fe6f0ba54787a">Fn</a>() { <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[0] = 1; <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[1] = 0; }</div>
<div class="line">  <span class="comment">// make Fn serializable</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Archive&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="struct_fn.html#aea3c94b2080ec50c5728f69563ff547d">serialize</a>(Archive&amp; ar) {</div>
<div class="line">    ar &amp; <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Archive&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="struct_fn.html#aea3c94b2080ec50c5728f69563ff547d">serialize</a>(Archive&amp; ar, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) {</div>
<div class="line">    ar &amp; <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="fibonacci_8cc.html#a0f9e65d0b745d1d332efa6b1a89582ca">make_ttg_fib_lt</a>(<span class="keyword">const</span> int64_t <a class="code hl_variable" href="fibonacci__device_8cc.html#a3fbac99789abad1b3a7a9207dc034901">F_n_max</a>) {</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;int64_t, Fn&gt;</a> f2f; <span class="comment">// fib to fib</span></div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;void, Fn&gt;</a> f2p;    <span class="comment">// fib to print</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> fib = ttg::make_tt(</div>
<div class="line">      [=](int64_t n, <a class="code hl_struct" href="struct_fn.html">Fn</a>&amp;&amp; f_n) {</div>
<div class="line">        int64_t next_f_n = f_n.F[0] + f_n.F[1];</div>
<div class="line">        f_n.F[1] = f_n.F[0];</div>
<div class="line">        f_n.F[0] = next_f_n;</div>
<div class="line">        <span class="keywordflow">if</span> (next_f_n &lt; <a class="code hl_variable" href="fibonacci__device_8cc.html#a3fbac99789abad1b3a7a9207dc034901">F_n_max</a>) {</div>
<div class="line">          <span class="comment">// send to next Fib</span></div>
<div class="line">          ttg::send&lt;0&gt;(n + 1, f_n);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="comment">// send to print</span></div>
<div class="line">          ttg::send&lt;1&gt;(n, f_n);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line">      <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(f2f), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(f2f, f2p), <span class="stringliteral">&quot;fib&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">print</a> = ttg::make_tt(</div>
<div class="line">      [=](<span class="keyword">const</span> <a class="code hl_struct" href="struct_fn.html">Fn</a>&amp; f_n) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;The largest Fibonacci number smaller than &quot;</span> &lt;&lt; <a class="code hl_variable" href="fibonacci__device_8cc.html#a3fbac99789abad1b3a7a9207dc034901">F_n_max</a> &lt;&lt; <span class="stringliteral">&quot; is &quot;</span> &lt;&lt; f_n.<a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[1] &lt;&lt; std::endl;</div>
<div class="line">      },</div>
<div class="line">      <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(f2p), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(), <span class="stringliteral">&quot;print&quot;</span>);</div>
<div class="line">  <span class="comment">// create a TTG that receives inputs on the first input of fib</span></div>
<div class="line">  <span class="keyword">auto</span> ins = std::make_tuple(fib-&gt;template in&lt;0&gt;());</div>
<div class="line">  <span class="comment">// collect fib and print into a vector</span></div>
<div class="line">  std::vector&lt;std::unique_ptr&lt;ttg::TTBase&gt;&gt; tts;</div>
<div class="line">  tts.emplace_back(std::move(fib));</div>
<div class="line">  tts.emplace_back(std::move(print));</div>
<div class="line">  <span class="comment">// instantiate the TTG; note the use of make_ttg instead of make_tt</span></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="namespacettg.html#af7f4deb4729fc2f5a5609fc521d5ffb9">make_ttg</a>(std::move(ops), ins, std::make_tuple(), <span class="stringliteral">&quot;Fib_n &lt; N&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="distributed_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a19c06079af2c21be154b525ff21028d1">ttg::initialize</a>(argc, argv, -1);</div>
<div class="line">  int64_t N = 1000;</div>
<div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) N = std::atol(argv[1]);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> fib = <a class="code hl_function" href="fibonacci_8cc.html#a0f9e65d0b745d1d332efa6b1a89582ca">make_ttg_fib_lt</a>(N);</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#ade4672895f07e88909dab1644c69e60a">ttg::make_graph_executable</a>(fib.get());</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a>();</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_function" href="namespacettg.html#a5829b255a41f2e47fa0e27bb5c791824">ttg::get_default_world</a>().<a class="code hl_function" href="namespacettg.html#ac0ad1dd3b87329e4acf9774df6dc8473">rank</a>() == 0)</div>
<div class="line">    fib-&gt;invoke(1, <a class="code hl_struct" href="struct_fn.html">Fn</a>{});</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a>();</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a96780ef3c553a2f45aa7ea881bdb6490">ttg::finalize</a>();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="afibonacci_8cc_html_a0f9e65d0b745d1d332efa6b1a89582ca"><div class="ttname"><a href="fibonacci_8cc.html#a0f9e65d0b745d1d332efa6b1a89582ca">make_ttg_fib_lt</a></div><div class="ttdeci">auto make_ttg_fib_lt(const int64_t F_n_max=1000)</div><div class="ttdef"><b>Definition</b> <a href="fibonacci_8cc_source.html#l00018">fibonacci.cc:18</a></div></div>
<div class="ttc" id="afibonacci__device_8cc_html_a3fbac99789abad1b3a7a9207dc034901"><div class="ttname"><a href="fibonacci__device_8cc.html#a3fbac99789abad1b3a7a9207dc034901">F_n_max</a></div><div class="ttdeci">const int64_t F_n_max</div><div class="ttdef"><b>Definition</b> <a href="fibonacci__device_8cc_source.html#l00014">fibonacci_device.cc:14</a></div></div>
<div class="ttc" id="anamespacettg_html_af7f4deb4729fc2f5a5609fc521d5ffb9"><div class="ttname"><a href="namespacettg.html#af7f4deb4729fc2f5a5609fc521d5ffb9">ttg::make_ttg</a></div><div class="ttdeci">auto make_ttg(ttseqT &amp;&amp;tts, const input_terminalsT &amp;ins, const output_terminalsT &amp;outs, const std::string &amp;name=&quot;ttg&quot;)</div><div class="ttdef"><b>Definition</b> <a href="tt_8h_source.html#l00120">tt.h:120</a></div></div>
<div class="ttc" id="aserialization_8h_html"><div class="ttname"><a href="serialization_8h.html">serialization.h</a></div></div>
<div class="ttc" id="astruct_fn_html"><div class="ttname"><a href="struct_fn.html">Fn</a></div><div class="ttdoc">N.B. contains values of F_n and F_{n-1}.</div><div class="ttdef"><b>Definition</b> <a href="fibonacci_8cc_source.html#l00006">fibonacci.cc:6</a></div></div>
<div class="ttc" id="astruct_fn_html_a5051d7a9e4e8ed81b27492ac526669d9"><div class="ttname"><a href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">Fn::F</a></div><div class="ttdeci">int64_t F[2]</div><div class="ttdef"><b>Definition</b> <a href="fibonacci_8cc_source.html#l00007">fibonacci.cc:7</a></div></div>
<div class="ttc" id="astruct_fn_html_a9b7f9114e90b36fc780fe6f0ba54787a"><div class="ttname"><a href="struct_fn.html#a9b7f9114e90b36fc780fe6f0ba54787a">Fn::Fn</a></div><div class="ttdeci">Fn()</div><div class="ttdef"><b>Definition</b> <a href="fibonacci_8cc_source.html#l00008">fibonacci.cc:8</a></div></div>
<div class="ttc" id="astruct_fn_html_aea3c94b2080ec50c5728f69563ff547d"><div class="ttname"><a href="struct_fn.html#aea3c94b2080ec50c5728f69563ff547d">Fn::serialize</a></div><div class="ttdeci">void serialize(Archive &amp;ar)</div><div class="ttdef"><b>Definition</b> <a href="fibonacci_8cc_source.html#l00010">fibonacci.cc:10</a></div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md52"></a>
Utility of &lt;tt&gt;Fn&lt;/tt&gt; struct</h4>
<p><code><a class="el" href="struct_fn.html" title="N.B. contains values of F_n and F_{n-1}.">Fn</a></code> aggregates 2 pieces of data that were separate before in preparation for aggregating datums into single continguous chunks that can be allocated on GPU more efficiently.This arrangement allows each task to access and modify both current and previous Fibonacci values without the need for separate data fields or additional communication overhead.</p>
<ul>
<li><code>F[0]</code> and <code>F[1]</code> store the current ($F_n$) and previous ($F_{n-1}$) Fibonacci numbers, respectively.</li>
<li>The default constructor starts the iteration by initializing <code>F[0]=1</code> and <code>F[1]=0</code>.</li>
</ul>
<p>Because <code><a class="el" href="struct_fn.html" title="N.B. contains values of F_n and F_{n-1}.">Fn</a></code> is now a user-defined type, for TTG to be able to copy/move it between tasks it needs to know how to serialize and deseralize it. functions are useful to communicate the struct among the tasks. TTG leverages these functions to serialize and deserialize the data as it is sent and received through the task graph.</p>
<h4><a class="anchor" id="autotoc_md53"></a>
Why &lt;tt&gt;make_ttg_fib_lt&lt;/tt&gt;?</h4>
<p>Until now we have constructed individual TTs and linked them together; i.e., the TTG until now was implicit. The function <code>make_ttg_fib_lt</code> instead explicitly creates a graph of TTs (a TTG). This seemingly small step helps improve composability by allowing to use entire TTGs as a component of other graphs by stitching it with TTs or TTGs together.</p>
<h3><a class="anchor" id="autotoc_md54"></a>
Device Version</h3>
<p>It is currently not possible to have a general-purpose task runtime execute purely on device, hence TTG and the underlying runtimes execute tasks on the host (CPU), and these tasks launch device <em>kernels</em>. For technical reasons it is necessary to split the code into the host-only part, which looks remarkably like the CPU-only version above, and the device-specific part that implements the core part of the computation on the device. In the future it <em>may</em> become possible to have single-source programs that contain both host and device parts contain in the same source file.</p>
<h4><a class="anchor" id="autotoc_md55"></a>
Host-side Code</h4>
<p>The host-only part is completely independent of the type of the device programming model.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_fn.html">Fn</a> : <span class="keyword">public</span> <a class="code hl_struct" href="structttg__parsec_1_1_t_t_value.html">ttg::TTValue</a>&lt;Fn&gt; {</div>
<div class="line">  std::shared_ptr&lt;int64_t[]&gt; <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>;  <span class="comment">// F[0] = F_n, F[1] = F_{n-1}</span></div>
<div class="line">  <a class="code hl_struct" href="structttg__parsec_1_1_buffer.html">ttg::Buffer&lt;int64_t&gt;</a> <a class="code hl_variable" href="struct_fn.html#a1d7ff4d5f731a83e2dfd9ae0751d3f07">b</a>; <span class="comment">// buffer managing host and device memory</span></div>
<div class="line">  <a class="code hl_function" href="struct_fn.html#a9b7f9114e90b36fc780fe6f0ba54787a">Fn</a>() : <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>(<a class="code hl_namespace" href="namespacestd.html">std</a>::make_shared&lt;int64_t[]&gt;(2)), <a class="code hl_variable" href="struct_fn.html#a1d7ff4d5f731a83e2dfd9ae0751d3f07">b</a>(<a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>.get(), 2) { <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[0] = 1; <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[1] = 0; }</div>
<div class="line">  <a class="code hl_function" href="struct_fn.html#a9b7f9114e90b36fc780fe6f0ba54787a">Fn</a>(<span class="keyword">const</span> <a class="code hl_struct" href="struct_fn.html">Fn</a>&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  <a class="code hl_function" href="struct_fn.html#a9b7f9114e90b36fc780fe6f0ba54787a">Fn</a>(<a class="code hl_struct" href="struct_fn.html">Fn</a>&amp;&amp; other) = <span class="keywordflow">default</span>;</div>
<div class="line">  <a class="code hl_struct" href="struct_fn.html">Fn</a>&amp; <a class="code hl_function" href="struct_fn.html#a6d982119a007475e6efa08598a15773e">operator=</a>(<span class="keyword">const</span> <a class="code hl_struct" href="struct_fn.html">Fn</a>&amp; other) = <span class="keyword">delete</span>;</div>
<div class="line">  <a class="code hl_struct" href="struct_fn.html">Fn</a>&amp; <a class="code hl_function" href="struct_fn.html#a6d982119a007475e6efa08598a15773e">operator=</a>(<a class="code hl_struct" href="struct_fn.html">Fn</a>&amp;&amp; other) = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Archive&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="struct_fn.html#aea3c94b2080ec50c5728f69563ff547d">serialize</a>(Archive&amp; ar) {</div>
<div class="line">    ar &amp; <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[0] &amp; <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[1] &amp; <a class="code hl_variable" href="struct_fn.html#a1d7ff4d5f731a83e2dfd9ae0751d3f07">b</a>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Archive&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="struct_fn.html#aea3c94b2080ec50c5728f69563ff547d">serialize</a>(Archive&amp; ar, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) {</div>
<div class="line">    ar &amp; <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[0] &amp; <a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[1] &amp; <a class="code hl_variable" href="struct_fn.html#a1d7ff4d5f731a83e2dfd9ae0751d3f07">b</a>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="fibonacci_8cc.html#a0f9e65d0b745d1d332efa6b1a89582ca">make_ttg_fib_lt</a>(<span class="keyword">const</span> int64_t <a class="code hl_variable" href="fibonacci__device_8cc.html#a3fbac99789abad1b3a7a9207dc034901">F_n_max</a> = 1000) {</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;int64_t, Fn&gt;</a> f2f;</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;void, Fn&gt;</a> f2p;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> fib = ttg::make_tt&lt;ES&gt;(</div>
<div class="line">      [=](int64_t n, <a class="code hl_struct" href="struct_fn.html">Fn</a>&amp;&amp; f_n) -&gt; ttg::device::Task {</div>
<div class="line">        assert(n &gt; 0);</div>
<div class="line">        <a class="code hl_function" href="namespacettg.html#af5e470229c1ddef41b83b6398a5dc583">ttg::trace</a>(<span class="stringliteral">&quot;in fib: n=&quot;</span>, n, <span class="stringliteral">&quot; F_n=&quot;</span>, f_n.<a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[0]);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// select a device and make b available</span></div>
<div class="line">        <span class="keyword">co_await</span> ttg::device::select(f_n.<a class="code hl_variable" href="struct_fn.html#a1d7ff4d5f731a83e2dfd9ae0751d3f07">b</a>);</div>
<div class="line">        <span class="comment">// compute the next value on the device (see below)</span></div>
<div class="line">        <a class="code hl_function" href="fibonacci__cuda__kernel_8h.html#afeeff85046f25c694e2056d73275e3f6">next_value</a>(f_n.<a class="code hl_variable" href="struct_fn.html#a1d7ff4d5f731a83e2dfd9ae0751d3f07">b</a>.<a class="code hl_function" href="structttg__parsec_1_1_buffer.html#ad7c9683797b26ee8911ae7cfe4712d50">current_device_ptr</a>());</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// wait for the task to complete and the values to be brought back to the host</span></div>
<div class="line">        <span class="keyword">co_await</span> ttg::device::wait(f_n.<a class="code hl_variable" href="struct_fn.html#a1d7ff4d5f731a83e2dfd9ae0751d3f07">b</a>);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (f_n.<a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[0] &lt; <a class="code hl_variable" href="fibonacci__device_8cc.html#a3fbac99789abad1b3a7a9207dc034901">F_n_max</a>) {</div>
<div class="line">          <span class="keyword">co_await</span> ttg::device::forward(ttg::device::send&lt;0&gt;(n + 1, std::move(f_n)));</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">          <span class="keyword">co_await</span> ttg::device::forward(ttg::device::sendv&lt;1&gt;(std::move(f_n)));</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line">      <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(f2f), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(f2f, f2p), <span class="stringliteral">&quot;fib&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">print</a> = ttg::make_tt(</div>
<div class="line">      [=](<a class="code hl_struct" href="struct_fn.html">Fn</a>&amp;&amp; f_n) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;The largest Fibonacci number smaller than &quot;</span> &lt;&lt; <a class="code hl_variable" href="fibonacci__device_8cc.html#a3fbac99789abad1b3a7a9207dc034901">F_n_max</a> &lt;&lt; <span class="stringliteral">&quot; is &quot;</span> &lt;&lt; f_n.<a class="code hl_variable" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">F</a>[1] &lt;&lt; std::endl;</div>
<div class="line">      },</div>
<div class="line">      <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(f2p), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(), <span class="stringliteral">&quot;print&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> ins = std::make_tuple(fib-&gt;template in&lt;0&gt;());</div>
<div class="line">  std::vector&lt;std::unique_ptr&lt;::ttg::TTBase&gt;&gt; ops;</div>
<div class="line">  ops.emplace_back(std::move(fib));</div>
<div class="line">  ops.emplace_back(std::move(print));</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="namespacettg.html#af7f4deb4729fc2f5a5609fc521d5ffb9">make_ttg</a>(std::move(ops), ins, std::make_tuple(), <span class="stringliteral">&quot;Fib_n &lt; N&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="distributed_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a19c06079af2c21be154b525ff21028d1">ttg::initialize</a>(argc, argv, -1);</div>
<div class="line">  int64_t N = 1000;</div>
<div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) N = std::atol(argv[1]);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> fib = <a class="code hl_function" href="fibonacci_8cc.html#a0f9e65d0b745d1d332efa6b1a89582ca">make_ttg_fib_lt</a>(N);</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#ade4672895f07e88909dab1644c69e60a">ttg::make_graph_executable</a>(fib.get());</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a>();</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_function" href="namespacettg.html#a78c09561304884c05c8a8f25006b0ee6">ttg::default_execution_context</a>().<a class="code hl_function" href="namespacettg.html#ac0ad1dd3b87329e4acf9774df6dc8473">rank</a>() == 0)</div>
<div class="line">    fib-&gt;template in&lt;0&gt;()-&gt;send(1, <a class="code hl_struct" href="struct_fn.html">Fn</a>{});;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a>();</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a96780ef3c553a2f45aa7ea881bdb6490">ttg::finalize</a>();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="afibonacci__cuda__kernel_8h_html_afeeff85046f25c694e2056d73275e3f6"><div class="ttname"><a href="fibonacci__cuda__kernel_8h.html#afeeff85046f25c694e2056d73275e3f6">next_value</a></div><div class="ttdeci">void next_value(int64_t *fn_and_fnm1)</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
<div class="ttc" id="anamespacettg_html_a78c09561304884c05c8a8f25006b0ee6"><div class="ttname"><a href="namespacettg.html#a78c09561304884c05c8a8f25006b0ee6">ttg::default_execution_context</a></div><div class="ttdeci">World default_execution_context()</div><div class="ttdoc">Accesses the default backend's default execution context.</div><div class="ttdef"><b>Definition</b> <a href="run_8h_source.html#l00110">run.h:110</a></div></div>
<div class="ttc" id="anamespacettg_html_af5e470229c1ddef41b83b6398a5dc583"><div class="ttname"><a href="namespacettg.html#af5e470229c1ddef41b83b6398a5dc583">ttg::trace</a></div><div class="ttdeci">void trace(const T &amp;t, const Ts &amp;... ts)</div><div class="ttdef"><b>Definition</b> <a href="trace_8h_source.html#l00044">trace.h:44</a></div></div>
<div class="ttc" id="astruct_fn_html_a1d7ff4d5f731a83e2dfd9ae0751d3f07"><div class="ttname"><a href="struct_fn.html#a1d7ff4d5f731a83e2dfd9ae0751d3f07">Fn::b</a></div><div class="ttdeci">ttg::Buffer&lt; int64_t &gt; b</div><div class="ttdef"><b>Definition</b> <a href="fibonacci__device_8cc_source.html#l00018">fibonacci_device.cc:18</a></div></div>
<div class="ttc" id="astruct_fn_html_a6d982119a007475e6efa08598a15773e"><div class="ttname"><a href="struct_fn.html#a6d982119a007475e6efa08598a15773e">Fn::operator=</a></div><div class="ttdeci">Fn &amp; operator=(const Fn &amp;other)=delete</div></div>
<div class="ttc" id="astructttg__parsec_1_1_buffer_html"><div class="ttname"><a href="structttg__parsec_1_1_buffer.html">ttg_parsec::Buffer</a></div><div class="ttdef"><b>Definition</b> <a href="parsec_2buffer_8h_source.html#l00247">buffer.h:247</a></div></div>
<div class="ttc" id="astructttg__parsec_1_1_buffer_html_ad7c9683797b26ee8911ae7cfe4712d50"><div class="ttname"><a href="structttg__parsec_1_1_buffer.html#ad7c9683797b26ee8911ae7cfe4712d50">ttg_parsec::Buffer::current_device_ptr</a></div><div class="ttdeci">pointer_type current_device_ptr()</div><div class="ttdef"><b>Definition</b> <a href="parsec_2buffer_8h_source.html#l00380">buffer.h:380</a></div></div>
<div class="ttc" id="astructttg__parsec_1_1_t_t_value_html"><div class="ttname"><a href="structttg__parsec_1_1_t_t_value.html">ttg_parsec::TTValue</a></div><div class="ttdef"><b>Definition</b> <a href="parsec_2ttvalue_8h_source.html#l00018">ttvalue.h:19</a></div></div>
</div><!-- fragment --><p>Although the structure of the device-capable program is nearly identical to the CPU version, there are important differences:</p>
<ul>
<li><code><a class="el" href="struct_fn.html" title="N.B. contains values of F_n and F_{n-1}.">Fn</a></code>'s data must exist on the host side (where the task is executed). To automate moving of the data between host and device memories <code><a class="el" href="struct_fn.html" title="N.B. contains values of F_n and F_{n-1}.">Fn</a></code> is implemented with the help of helper classes <code>TTValue</code> and <code>Buffer</code>.</li>
<li>task functions become <em>coroutines</em> (as indicated by their return type <code>device::Task</code>) to deal with the asynchrony of the host-device interactions (kernel launch, memory allocation and transfers)</li>
<li>the target execution space is specified as a template argument of type <code>ExecutionSpace</code> to <code>make_tt</code></li>
</ul>
<p><a class="anchor" id="autotoc_md56"></a> </p><h5><code>TTValue</code></h5>
<p>For optimal performance, the low-level runtime that manages the data motion across the memory hierarchy (host-to-host (i.e., between MPI ranks), host-to-device, and device-to-device) and so it must be able to <em>track</em> each datum as it orchestrates the computation. For example, when a TTG task sends a datum to an output terminal connected to multiple consumers the runtime may avoid unnecessary copies, e.g., by recognizing that all consumers will only need read-only access to the data, hence reference to the same datum can be passed to all consumers. This requires the mapping of a pointer to a C++ object to the control block that describes that object to the runtime. Deriving C++ type <code>T</code> from <code>TTValue&lt;T&gt;</code> includes the control block in <code>T</code> and avoids creating a separate control block. This is particularly important for the data that has to travel to the device.</p>
<p><a class="anchor" id="autotoc_md57"></a> </p><h5><code>Buffer</code></h5>
<p><code>Buffer&lt;T&gt;</code> is a view of a contiguous sequence of objects of type <code>T</code> in the host memory that can be automatically moved by the runtime to/from the device memory. Here <code><a class="el" href="struct_fn.html#a1d7ff4d5f731a83e2dfd9ae0751d3f07">Fn::b</a></code> is a view of the 2-element sequence pointed to by <code><a class="el" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">Fn::F</a></code>; once it's constructed the content of <code><a class="el" href="struct_fn.html#a5051d7a9e4e8ed81b27492ac526669d9">Fn::F</a></code> will be moved to/from the device by the runtime. The subsequent use of <code><a class="el" href="struct_fn.html#a1d7ff4d5f731a83e2dfd9ae0751d3f07">Fn::b</a></code> cause the automatic transfers of data to (<code>device::select(f_n.b)</code>) and from (<code>ttg::device::wait(f_n.b)</code>) the device. A <code>Buffer&lt;T&gt;</code> can be either freestanding or with lifetime tied to the lifetime of the host buffer; the latter is used in the example above, indicated by the use of <code>shared_ptr</code> to manage the lifetime of the host buffer. If no pointer is passed to the constructor of <code>Buffer&lt;T&gt;</code> the buffer allocates the necessary host-side memory. In order to guarantee relocatability of buffers, the data managed by a buffer should be located on the heap, i.e., dynamically allocated.</p>
<p><a class="anchor" id="autotoc_md58"></a> </p><h5><code>device::Task</code></h5>
<p>The key challenge of device programming models is that they are fundamentally <em>asynchronous</em> to hide the latency of interacting with the device. Kernel launches, unlike function calls on CPU, as well as memory transfers take 1000s of CPU cycles, and the asynchrony helps amortize these costs by overlapping kernels launch and execution. Task programming models are a seemingly good match for device programming, but the key challenge is how to make device-capable task code look most like standard host-only task code. TTG ability to use <em>C++ coroutines</em> as task bodies allows it to deal with asynchronous calls inside the tasks (the use of coroutines is the primary reason why TTG requires C++20 support by the C++ compiler). Roughly speaking, coroutines are resumable functions; they can return to the caller via a <code>co_await</code> statement and be resumed at that point once some condition (typically, completion of submitted actions) has been satisfied. Device tasks <code>co_await</code> at every point where further progress requires completion of preceding device tasks:</p>
<ul>
<li>The first <code>co_await ttg::device::select</code> asks the runtime to select a device (if multiple are available) and ensures that the contents of <code>f_n.F[]</code> are made available on that device. During the first invocation the data resides on the host, hence the runtime allocates memory on the device and transfers the contents of <code>f_n.F[]</code> from host to device. During subsequent invocations the contents of <code>f_n.F[]</code> are likely already available on the device (unless the runtime decides to compute $F_{n+1}$ on a different device than $F_n$), thus this <code>co_await</code> may become a no-op.</li>
<li>The second <code>co_await ttg::device::wait</code> ensures that the kernel launched by <code>next_value</code> has completed and the contents of <code>f_n.F[]</code> changed by that kernel are available on the host. This always causes device-to-host transfer if one or more <code>Buffer&lt;T&gt;</code> are provided. If no buffer is provided then the call only waits for all previously submitted kernels to complete.</li>
<li>The last set of <code>co_await</code>'s ensures that the corresponding <code>ttg::device::send</code>, which sends the data located in the device memory, has completed. Since <code>device::send</code> within a task may return a local variable (e.g., for the key) exit from the coroutine would destroy such variables prematurely, hence instead of a <code>co_return</code> the coroutine concludes by waiting for the <code>device::send</code> to complete before exiting.</li>
</ul>
<p><a class="anchor" id="autotoc_md59"></a> </p><h5><code>ExecutionSpace</code></h5>
<p>TTG and its underlying runtime needs to be told in which <em>execution space</em> the task code will operate in. The current choices are denoted by the <code>ExecutionSpace</code> enumeration:</p>
<ul>
<li><code>ExecutionSpace::Host</code>: host processor (default)</li>
<li><code>ExecutionSpace::CUDA</code>: an NVIDIA CUDA device</li>
<li><code>ExecutionSpace::HIP</code>: an AMD HIP device</li>
<li><code>ExecutionSpace::L0</code>: an Intel L0 device</li>
</ul>
<h4><a class="anchor" id="autotoc_md60"></a>
Device Kernel</h4>
<p>Here's the CUDA version of the device kernel and its host-side wrapper; ROCm and SYCL/Level0 variants will be very similar to the CUDA version:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="fibonacci__cuda__kernel_8h.html">fibonacci_cuda_kernel.h</a>&quot;</span></div>
<div class="line">    __global__ <span class="keywordtype">void</span> cu_next_value(int64_t* fn_and_fnm1) {</div>
<div class="line">      int64_t fnp1 = fn_and_fnm1[0] + fn_and_fnm1[1];</div>
<div class="line">      fn_and_fnm1[1] = fn_and_fnm1[0];</div>
<div class="line">      fn_and_fnm1[0] = fnp1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="fibonacci__cuda__kernel_8h.html#afeeff85046f25c694e2056d73275e3f6">next_value</a>(int64_t* fn_and_fnm1) {</div>
<div class="line">      cu_next_value&lt;&lt;&lt;1, 1&gt;&gt;&gt;(fn_and_fnm1);</div>
<div class="line">    }</div>
<div class="ttc" id="afibonacci__cuda__kernel_8h_html"><div class="ttname"><a href="fibonacci__cuda__kernel_8h.html">fibonacci_cuda_kernel.h</a></div></div>
</div><!-- fragment --><p><code>cu_next_value</code> is the device kernel that evaluates $F_{n+1}$ from $F_{n}$ and $F_{n-1}$. <code>next_value</code> is a host function that launches <code>cu_next_value</code>; this is the function called in the <code>fib</code> task.</p>
<h2><a class="anchor" id="autotoc_md61"></a>
Debugging TTG Programs</h2>
<h3><a class="anchor" id="autotoc_md62"></a>
TTG Visualization</h3>
<p>TTGs can be exported in <a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">the DOT format</a> as follows:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <a class="code hl_class" href="classttg_1_1_dot.html">ttg::Dot</a>()(tt.get()) &lt;&lt; std::endl;</div>
<div class="ttc" id="aclassttg_1_1_dot_html"><div class="ttname"><a href="classttg_1_1_dot.html">ttg::Dot</a></div><div class="ttdoc">Prints the graph to a std::string in the format understood by GraphViz's dot program.</div><div class="ttdef"><b>Definition</b> <a href="dot_8h_source.html#l00014">dot.h:14</a></div></div>
</div><!-- fragment --><p>Use <a href="https://www.graphviz.org/">GraphViz</a> to visualize the resulting graph.</p>
<h3><a class="anchor" id="autotoc_md63"></a>
Task Graph Visualization</h3>
<p>Exporting the DAG of tasks resulting from execution of a TTG will be possible as soon as <a href="https://github.com/TESSEorg/ttg/pull/227">PR 227</a> has been merged.</p>
<h3><a class="anchor" id="autotoc_md64"></a>
Launching a Debugger</h3>
<p>To simplify debugging of multirank TTG programs it is possible to automate the process as follows:</p><ul>
<li>If an X11 server is running (check if environment variable <code>DISPLAY</code> is set), then set environment variable <code>TTG_DEBUGGER</code> to {<code>gdb_xterm</code>,<code>lldb_xterm</code>} to launch {<code>gdb</code>,<code>lldb</code>} upon receiving a signal like <code>SIGSEGV</code> or <code>SIGABRT</code> (one <code>xterm</code> window per rank will be created);</li>
<li>If an X11 server is not running the set <code>TTG_DEBUGGER</code> to empty value; upon receiving a signal the program will print instructions for how to attach a debugger to a running process from another terminal.</li>
<li>run the ttg program and if it receives any signal the xterm windows should pop up to display debugging results</li>
</ul>
<h1><a class="anchor" id="autotoc_md65"></a>
TTG Performance</h1>
<p>Competitive performance of TTG for several paradigmatic scientific applications on shared- and distributed-memory machines (CPU only) was discussed in manuscripts <a href="https://doi.org/10.1109/IPDPS53621.2022.00086">`&lsquo;Generalized Flow-Graph Programming Using Template Task-Graphs: Initial Implementation and Assessment&rsquo;'</a> and <a href="https://doi.org/10.1109/PAW-ATM56565.2022.00008">`&lsquo;Composition of Algorithmic Building Blocks in Template Task Graphs&rsquo;'</a>. Low-level benchmarking of TTG tasking was reported in manuscript <a href="https://doi.org/10.1109/CLUSTER51413.2022.00026">`&lsquo;Pushing the Boundaries of Small Tasks: Scalable Low-Overhead Data-Flow Programming in TTG&rsquo;'</a>.</p>
<h1><a class="anchor" id="autotoc_md66"></a>
TTG Performance Tracing</h1>
<p>There are several ways to trace execution of a TTG program. The easiest way is to use the PaRSEC-based TTG backend to produce binary traces in PaRSEC Binary Trace (PBT) format and then convert them to a Chrome Trace Format (CTF) JSON file that can be visuzalized using built-in browser in Chrome browser or using web-based <a href="https://ui.perfetto.dev/">Perfetto trace viewer</a>. To generate the trace results of any TTG program follow the process discussed below:</p>
<ul>
<li>For simplicity, we assume here that TTG will build PaRSEC from source. Make sure PaRSEC Python tools prerequisites have been installed, namely Python3 (version 3.8 is recommended) and the following Python packages (e.g., using <code>pip</code>):<ul>
<li><code>cython</code></li>
<li><code>numpy</code></li>
<li><code>pandas</code></li>
<li><code>tables</code></li>
</ul>
</li>
<li>Configure and build TTG:<ul>
<li>Configure TTG with <code>-DPARSEC_PROF_TRACE=ON</code> (this turns on PaRSEC task tracing) and <code>-DBUILD_SHARED_LIBS=ON</code> (to support PaRSEC Python tools). Also make sure that CMake discovers the Python3 interpreter and the <code>cython</code> package.</li>
<li>Build and install TTG</li>
</ul>
</li>
<li>Build the TTG program to be traced.</li>
<li>Run the TTG program with tracing turned on:<ul>
<li>Set the environment variables <code>PARSEC_MCA_mca_pins</code> and <code>PARSEC_MCA_profile_filename</code> to <code>task_profiler</code> and the PBT file name <em>prefix</em> (e.g. <code>/tmp/ttg</code>), respectively.</li>
<li>Run the program and make sure the trace files (in PBT format) have been generated; e.g., if you set <code>PARSEC_MCA_profile_filename</code> to <code>/tmp/ttg</code> you should find file <code>/tmp/ttg-0.prof-...</code> containing the trace from MPI rank 0, <code>/tmp/ttg-1.prof-...</code> from rank 1, and so on.</li>
</ul>
</li>
<li>Convert the traces from PaRSEC Binary Trace (PBT) format to the Chrome Trace Format (CTF):<ul>
<li>Add <code>{TTG build directory}/_deps/parsec-build/tools/profiling/python/python.test</code> (currently it is not possible to use PaRSEC Python module from the install tree, only from its build tree) to the <code>PYTHONPATH</code> environment variable so that the Python interpreter can find the modules for reading the PaRSEC trace files.</li>
<li>Convert the PBT files to a CTF file by running the conversion script: <div class="fragment"><div class="line">{TTG install prefix}/bin/pbt_to_ctf.py {PBT file name prefix} {CTF filename}</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Open the <code>chrome://tracing</code> URL in the Chrome browser and load the resulting trace; alternatively you can use the <a href="https://ui.perfetto.dev/">Perfetto trace viewer</a> from any browser.</li>
</ul>
<p>For example, executing the Fibonacci program described above using 2 MPI processes and with 2 threads each will produce a trace that looks like this:</p>
<div class="image">
<img src="nth-fib-trace-2proc-2thr.png" alt=""/>
<div class="caption">
Fibonacci_traces_example</div></div>
    <h1><a class="anchor" id="autotoc_md67"></a>
TTG reference documentation</h1>
<p>TTG API documentation is available for the following versions:</p>
<ul>
<li><a href="https://tesseorg.github.io/ttg/dox-master">master branch</a> .</li>
</ul>
<h1><a class="anchor" id="autotoc_md68"></a>
Cite</h1>
<p>When referring to TTG in an academic setting please cite the following publication:</p><ul>
<li>G. Bosilca, R. J. Harrison, T. Herault, M. M. Javanmard, P. Nookala and E. F. Valeev, "The Template Task Graph (TTG) - an emerging practical dataflow programming paradigm for scientific simulation at extreme scale," 2020 IEEE/ACM Fifth International Workshop on Extreme Scale Programming Models and Middleware (ESPM2), 2020, pp. 1-7, doi: <a href="https://dx.doi.org/10.1109/ESPM251964.2020.00011">10.1109/ESPM251964.2020.00011</a>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md69"></a>
Acknowledgment</h1>
<p>The development of TTG was made possible by:</p>
<ul>
<li><a href="https://tesseorg.github.io/">The EPEXA project</a>, currently supported by the National Science Foundation under grants <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1931387">1931387</a> to Stony Brook University, <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1931384">1931384</a> to the University of Tennessee, Knoxville, and <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1931347">1931347</a> to Virginia Tech.</li>
<li>The TESSE project, supported by the National Science Foundation under grants <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1450344">1450344</a> to Stony Brook University, <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1450300">1450300</a> at the University of Tennesse, Knoxville, and <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1450262">1450262</a> to Virginia Tech. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Tue Feb 10 2026 20:41:12 for <a href="https://https://github.com/ValeevGroup/tiledarray/">ttg</a>
    1.0.0 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.8
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
