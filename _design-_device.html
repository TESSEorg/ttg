<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>ttg: Device Task Design</title>
    <!--BEGIN PROJECT_ICON-->
    <link rel="icon" href="$projecticon" type="image/x-icon" />
    <!--END PROJECT_ICON-->
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <!--BEGIN COPY_CLIPBOARD-->
    <script type="text/javascript" src="clipboard.js"></script>
    <!--END COPY_CLIPBOARD-->
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init();
        DoxygenAwesomeParagraphLink.init();
    </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                <tr id="projectrow">
                    <td id="projectalign">
                        <div id="projectname">ttg<span id="projectnumber">&#160;1.0.0</span>
                        </div>
                        <div id="projectbrief">Template Task Graph (TTG): flowgraph-based programming model for high-performance distributed-memory algorithms</div>
                    </td>
                </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Device Task Design</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md10"></a>
problem statement</h1>
<p>TTG must be able to execute general user-defined graphs on machines with heterogeneous execution and address spaces, e.g., using multiple processes each having multiple CPU threads + device streams, with each thread/stream preferring or limited to a specific address range.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
key concerns</h1>
<p>The key issues are how to manage:</p><ul>
<li>the asynchrony of the device programming models, and</li>
<li>the heterogeneity of the address space.</li>
</ul>
<p>There are multiple "solutions" to each issue, hence there are many possible designs. I'll discuss each issue first, then outline the aggregate designs we are pursuing.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Memory:</h2>
<ul>
<li><em>Unified Memory (UM)</em>: where available, use single address space (unified memory visible to both host and device executors; it is also possible to use pinned host memory for device calls)<ul>
<li>pro: simplifies memory management by removing the capacity limitation</li>
<li>con: still needs user cooperation: all compute data must be allocated on UM heap, this impacts the design of user data types, e.g. making them allocator aware, etc.</li>
<li>con: the user will likely needs to use pooled memory management for efficiency reasons (e.g., TiledArray uses Umpire)</li>
<li>con: still necessary to provide hints to the kernel driver managing UM.</li>
<li>con: reasoning about UM driver performance is difficult, its details are opaque and platform dependent.</li>
</ul>
</li>
<li><em>Device Memory (DM)</em>: using "native" device memory.<ul>
<li>pro: simpler performance model due to greatest amount of control (by runtime) over execution</li>
<li>pro: can work with stack-capable data types</li>
<li>con: The amount is limited, hence this memory must be explicitly managed (akin to how a cache is managed).</li>
</ul>
</li>
</ul>
<p>Additional memory-related concerns common to both models:</p><ul>
<li>only partial state needs to be transferred to/from the device<ul>
<li>which part of the state will differ from algorithm to algorithm, hence encoding/constructing such representation cannot use constexpr code (such as traits)</li>
<li>the need for <em>explicit</em> handling of object's partial state is shared by both models<ul>
<li>UM: such optimization may seem automatic (only the pages of the data actually used on the device are transfered) but in practice the data must be explicitly prefetched, hence partial state transfers are not automatic; furthermore, the unit of UM transfer is a page (4k or more), which is too coarse for many applications</li>
<li>DM: serialization of an entire object (which can leverage standard RDMA-like serialization), transfering partial state requires explicit annotation</li>
</ul>
</li>
<li>hence it makes sense to make representation of object's partial state (<code>View</code>) a first-class concept in both models.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
Asynchrony</h2>
<ul>
<li><em>Continuations/stages</em>: decompose tasks into <em>continuations</em> (stages), with runtime-managed scheduling of continutations for managing the asynchrony of the actions initiated by each continuation<ul>
<li>pro: most explicit, easier to reason about, fewest performance implications</li>
<li>con: most verbose; device-capable tasks look very different from host tasks</li>
<li>con: limited composability<ul>
<li>difficult to support general computation patterns (e.g. generator continuation, etc.,)</li>
</ul>
</li>
</ul>
</li>
<li>*"Threads"*: use threads to deal with the asynchrony (in principle could use user-space threads = fibers)<ul>
<li>pro: least host/device dichotomy<ul>
<li>tasks are ordinary (synchronous) functions</li>
<li>fully composable</li>
</ul>
</li>
<li>con: performance implications<ul>
<li>due to the need to context switch to "yield" to other tasks</li>
<li>thus even fully synchronous computations will suffer</li>
</ul>
</li>
<li>con: asynchrony artifacts still appear<ul>
<li>asynchronous calls must be in general annotated (to force synchronous execution and/or to provide hints to the thread scheduler)</li>
</ul>
</li>
</ul>
</li>
<li>*"Coroutines"*: use C++20 coroutines<ul>
<li>pro: less host/device dichotomy compared to continuations<ul>
<li>task functions "look" like ordinary functions (and can be made almost like normal functions using macros) but returning a custom return object (containing return status + handle to the coroutine) instead of void</li>
<li>fully composable</li>
</ul>
</li>
<li>performance implications<ul>
<li>pro: no impact on synchronous tasks</li>
<li>con: coroutine implementation details are complex and usually involve heap allocation</li>
<li>pro: custom allocators can be introduced to elide heap allocation (at the cost of limited generality)</li>
</ul>
</li>
<li>con: asynchrony artifacts still appear<ul>
<li>co_await annotate the spots where execution may need to be suspended</li>
</ul>
</li>
<li>con: less mature due to the need for C++20<ul>
<li>GCC (10+), LLVM (8+) support coroutines</li>
<li>TTG and all of its dependencies will be impacted by the raised standard requirement</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
other considerations</h2>
<ul>
<li>it's not possible to manage memory from the device code, hence all program logic, including <em>device-capable</em> tasks, must execute on host executors. In principle if we restricted ourselves to a single-source language (SYLC-extended C++) we could write device capable tasks directly as device code, but current language limitations mandate wrapping everything into host code.</li>
<li>runtime is still responsible for managing the executor space heterogeneity (control where to launch a task) and asynchrony (events/host callbacks).</li>
</ul>
<h1><a class="anchor" id="autotoc_md15"></a>
Current designs</h1>
<ul>
<li><em>UM+threads</em>: use UM for memory management + threads for asynchrony</li>
<li><em>DM+stages</em>: use Parsec's device memory pool manager + stage-decomposed tasks</li>
<li><em>?M+coroutines</em>: UM/DM for memory + C++20 coroutines for handling the asynchrony</li>
</ul>
<h2><a class="anchor" id="autotoc_md16"></a>
Example code: threads vs continuations vs coroutines</h2>
<p>How should we map the following host task onto the device? </p><div class="fragment"><div class="line"><a class="code hl_function" href="make__tt_8h.html#a85366a0c478cf3d6b3018f1f29576562">make_tt</a>([](<span class="keyword">auto</span>&amp; key, <span class="keyword">auto</span>&amp; data1, <span class="keyword">auto</span>&amp; data2) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="keywordtype">double</span> data3 = blas::dot(data1.data(), data2.data());</div>
<div class="line">    <span class="keywordflow">if</span> (data3 &gt;= 0.)</div>
<div class="line">        send&lt;0&gt;(data1);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        send&lt;0&gt;(data2);</div>
<div class="line">}</div>
<div class="ttc" id="amake__tt_8h_html_a85366a0c478cf3d6b3018f1f29576562"><div class="ttname"><a href="make__tt_8h.html#a85366a0c478cf3d6b3018f1f29576562">make_tt</a></div><div class="ttdeci">auto make_tt(funcT &amp;&amp;func, const std::tuple&lt; ttg::Edge&lt; keyT, input_edge_valuesT &gt;... &gt; &amp;inedges=std::tuple&lt;&gt;{}, const std::tuple&lt; output_edgesT... &gt; &amp;outedges=std::tuple&lt;&gt;{}, const std::string &amp;name=&quot;wrapper&quot;, const std::vector&lt; std::string &gt; &amp;innames=std::vector&lt; std::string &gt;(sizeof...(input_edge_valuesT), &quot;input&quot;), const std::vector&lt; std::string &gt; &amp;outnames=std::vector&lt; std::string &gt;(sizeof...(output_edgesT), &quot;output&quot;))</div><div class="ttdoc">Factory function to assist in wrapping a callable with signature.</div><div class="ttdef"><b>Definition</b> <a href="make__tt_8h_source.html#l00492">make_tt.h:492</a></div></div>
</div><!-- fragment --><p>Ideally the task will receive <code>data1</code> and <code>data2</code> already transferred to the memory space(s) accessible from the device execution space: </p><div class="fragment"><div class="line">make_device_tt([](<span class="keyword">auto</span>&amp; key, <span class="keyword">auto</span>&amp; data1, <span class="keyword">auto</span>&amp; data2) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="keywordtype">double</span> data3 = blas::device_dot(data1.data(), data2.data());</div>
<div class="line">    <span class="keywordflow">if</span> (data3 &gt;= 0.)</div>
<div class="line">        send&lt;0&gt;(data1);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        send&lt;0&gt;(data2);</div>
<div class="line">}</div>
</div><!-- fragment --><p> But now <code>data3</code> lives in the host memory so in general we must manage its transfer from the device. Hence either:</p><ul>
<li>all intermediate data must be managed explicitly within the task, or</li>
<li>except for the cases where user types are aware of multiple memory spaces (but this makes the state of such types asynchronous).</li>
</ul>
<p>Here are the tentative device versions of this task in each of the 3 approaches (the memory details are omitted).</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Threads</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="make__tt_8h.html#a85366a0c478cf3d6b3018f1f29576562">make_tt</a>([](<span class="keyword">auto</span>&amp; key, <span class="keyword">auto</span>&amp; data1, <span class="keyword">auto</span>&amp; data2) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">    <span class="comment">// stage 1</span></div>
<div class="line">    ConstView view1(data1);</div>
<div class="line">    ConstView view2(data2);</div>
<div class="line">    <span class="keywordtype">double</span> data3;</div>
<div class="line">    View view3(data3, NewView | SyncView_D2H);</div>
<div class="line">    <span class="comment">// depending on the memory model may need to wait here for the transfers to complete</span></div>
<div class="line">    <span class="comment">// could build the waits into View ctors, or need an explicit await()</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// stage 2</span></div>
<div class="line">    cublasDdot(view1.device_ptr(), view2.device_ptr(), view3.device_ptr());</div>
<div class="line">    <span class="comment">// if called an async function need explicit await() here</span></div>
<div class="line">    <span class="comment">// also: who/how will view3 be synchronized</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (data3 &gt;= 0.)</div>
<div class="line">        send&lt;0&gt;(data1);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        send&lt;0&gt;(data2);</div>
<div class="line">}</div>
</div><!-- fragment --><p> N.B. <code>make_tt</code>: this is a regular task.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Continuations</h3>
<div class="fragment"><div class="line">make_device_tt(</div>
<div class="line">  <span class="comment">// stage 1</span></div>
<div class="line">  [](<span class="keyword">auto</span>&amp; key, <span class="keyword">auto</span>&amp; data1, <span class="keyword">auto</span>&amp; data2) {</div>
<div class="line">    ConstView view1(data1);</div>
<div class="line">    ConstView view2(data2);</div>
<div class="line">    <span class="keywordtype">double</span> data3;</div>
<div class="line">    View view3(data3, NewView | SyncView_D2H);</div>
<div class="line">    <span class="keywordflow">return</span> {view1, view2, view3};</div>
<div class="line">    }, </div>
<div class="line">  <span class="comment">// stage 2</span></div>
<div class="line">  [](<span class="keyword">auto</span>&amp; key, <span class="keyword">auto</span>&amp; views) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; [view1, view2, view3] = views;</div>
<div class="line">    cublasDdot(view1.device_ptr(), view2.device_ptr(), view3.device_ptr());</div>
<div class="line">  },</div>
<div class="line">  <span class="comment">// stage 3</span></div>
<div class="line">  [](<span class="keyword">auto</span>&amp; key, <span class="keyword">auto</span>&amp; views) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; [view1, view2, view3] = views;</div>
<div class="line">    <span class="keywordflow">if</span> (*view3.host_ptr() &gt;= 0.)</div>
<div class="line">        send&lt;0&gt;(data1);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        send&lt;0&gt;(data2);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> N.B. <code>make_device_tt</code> vs <code>make_tt</code>: this is a special task.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
Coroutines</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="make__tt_8h.html#a85366a0c478cf3d6b3018f1f29576562">make_tt</a>([](<span class="keyword">auto</span>&amp; key, <span class="keyword">auto</span>&amp; data1, <span class="keyword">auto</span>&amp; data2) -&gt; <a class="code hl_struct" href="structttg_1_1resumable__task.html">ttg::resumable_task</a> {</div>
<div class="line">    <span class="comment">// stage 1</span></div>
<div class="line">    ConstView view1(data1);</div>
<div class="line">    ConstView view2(data2);</div>
<div class="line">    <span class="keywordtype">double</span> data3;</div>
<div class="line">    View view3(data3, NewView | SyncView_D2H);</div>
<div class="line">    <span class="keyword">co_await</span> sync_views(view1, view2, view3);  <span class="comment">// creates list of transfers to be fulfilled by the runtime</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// stage 2</span></div>
<div class="line">    cublasDdot(view1.device_ptr(), view2.device_ptr(), view3.device_ptr());</div>
<div class="line">    <span class="keyword">co_await</span>;  <span class="comment">// syncs view3; since transfers and kernels execute in different streams the runtime will sync kernel stream, then launch transfers, then resume here</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (data3 &gt;= 0.)</div>
<div class="line">        send&lt;0&gt;(data1);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        send&lt;0&gt;(data2);</div>
<div class="line">    <span class="keyword">co_return</span>;  <span class="comment">// processes sends and destroys coroutine</span></div>
<div class="line">}, ...);</div>
<div class="ttc" id="astructttg_1_1resumable__task_html"><div class="ttname"><a href="structttg_1_1resumable__task.html">ttg::resumable_task</a></div><div class="ttdoc">task that can be resumed after some events occur</div><div class="ttdef"><b>Definition</b> <a href="coroutine_8h_source.html#l00054">coroutine.h:54</a></div></div>
</div><!-- fragment --><p> N.B. <code>make_tt</code> and <code><a class="el" href="structttg_1_1resumable__task.html" title="task that can be resumed after some events occur">ttg::resumable_task</a></code>: this is a regular task but with special return type. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Tue Feb 10 2026 20:41:12 for <a href="https://https://github.com/ValeevGroup/tiledarray/">ttg</a>
    1.0.0 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.8
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
