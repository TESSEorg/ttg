<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>ttg: Template Task Graph User Guide</title>
    <!--BEGIN PROJECT_ICON-->
    <link rel="icon" href="$projecticon" type="image/x-icon" />
    <!--END PROJECT_ICON-->
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <!--BEGIN COPY_CLIPBOARD-->
    <script type="text/javascript" src="clipboard.js"></script>
    <!--END COPY_CLIPBOARD-->
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init();
        DoxygenAwesomeParagraphLink.init();
    </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                <tr id="projectrow">
                    <td id="projectalign">
                        <div id="projectname">ttg<span id="projectnumber">&#160;1.0.0</span>
                        </div>
                        <div id="projectbrief">Template Task Graph (TTG): flowgraph-based programming model for high-performance distributed-memory algorithms</div>
                    </td>
                </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Template Task Graph User Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="toc"></a>
Contents</h1>
<ul>
<li><a href="https://github.com/TESSEorg/ttg/blob/master/INSTALL.md">Building and Installing TTG</a></li>
<li><a class="el" href="userguide.html#firstprog">Your First TTG Program</a></li>
<li><a class="el" href="userguide.html#compiling">Compiling Your First TTG Program</a></li>
<li><a class="el" href="userguide.html#datadependent">Data-Dependent Program</a></li>
<li><a class="el" href="userguide.html#streamingterminals">Streaming Terminals</a></li>
<li><a class="el" href="userguide.html#distributedcomputing">Distributed Computing</a></li>
</ul>
<h1><a class="anchor" id="firstprog"></a>
Your First TTG Program</h1>
<p>The following code creates four tasks, one of type A, two of type B (B(0) and B(1)), and one of type C, and ensures that A runs before both B tasks, and that both B tasks run before C.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_simple.svg" width="394" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
Simple diamond DAG</div>
</div>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ttg.h&gt;</span></div>
</div><!-- fragment --><p> To implement a TTG program, the user just needs to include <code>ttg.h</code>. The selection of the task backend is usually done at compile time through a compiler definition. However, before include <code>ttg.h</code>, the user could <code>#define TTG_USE_PARSEC 1</code> or <code>#define TTG_USE_MADNESS 1</code>. Note that only one of the backends can be defined, and the recommended way is to define which backend is used when invoking the compiler (see <a class="el" href="userguide.html#compiling">Compiling Your First TTG Program</a> below).</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> a(std::tuple&lt;<a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;int, double&gt;</a>&gt; &amp;out) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task A &quot;</span>);</div>
<div class="line"> </div>
  <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a>&lt;0&gt;(0, 1.0, out);<div class="line"> </div>
  <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a>&lt;0&gt;(1, 2.0, out);<div class="line">}</div>
<div class="ttc" id="aclassttg_1_1_out_html"><div class="ttname"><a href="classttg_1_1_out.html">ttg::Out</a></div><div class="ttdef"><b>Definition</b> <a href="terminal_8h_source.html#l00430">terminal.h:430</a></div></div>
<div class="ttc" id="anamespacettg_html_a1b23b6cea5360627c9f1e1e9f421bcf3"><div class="ttname"><a href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a></div><div class="ttdeci">void send()</div><div class="ttdoc">Sends a control message (message without an accompanying task id or a value) to the template tasks at...</div><div class="ttdef"><b>Definition</b> <a href="func_8h_source.html#l00341">func.h:341</a></div></div>
<div class="ttc" id="anamespacettg_html_aa3510e128b769afb53720d24fa83fb97"><div class="ttname"><a href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a></div><div class="ttdeci">void print(const T &amp;t, const Ts &amp;... ts)</div><div class="ttdoc">atomically prints to std::cout a sequence of items (separated by ttg::print_separator) followed by st...</div><div class="ttdef"><b>Definition</b> <a href="print_8h_source.html#l00131">print.h:131</a></div></div>
</div><!-- fragment --><p> This is the function that implements tasks of type A. Tasks of this type have no key to identify them, and receive no input data. Their only output terminal is defined to receive a key of type <code>int</code> and a value of type <code>double</code>.</p>
<p>We use <code><a class="el" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97" title="atomically prints to std::cout a sequence of items (separated by ttg::print_separator) followed by st...">ttg::print</a></code> to printout information, as a convenience function that also avoids messages from multiple threads to interfere with each other.</p>
<p>The task sends the value <code>1.0</code> to <code>B(0)</code> by outputing the key of type <code>int</code> and value <code>0</code> with the data of type <code>double</code> and value <code>1.0</code> on the output terminal of index <code>&lt;0&gt;</code>, and the key of type <code>int</code> and value <code>1</code> with the data of type <code>double</code> and value <code>2.0</code> on the same output terminal.</p>
<p>Because the two keys are different, these two <code><a class="el" href="namespacettg.html#a195eb3c0d9b0118dd7c94c0463840734" title="Sends a task id and a value to the given output terminal.">ttg::send</a></code> instantiate two different target tasks. Which task depends on how the function is wrapped into a template task (TT), and how the terminals of this template task are connected to other terminals of template tasks (see below).</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> b(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;key, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;input, std::tuple&lt;<a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;void, double&gt;</a>, <a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;void, double&gt;</a>&gt; &amp;out) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task B(&quot;</span>, key, <span class="stringliteral">&quot;) with input data &quot;</span>, input);</div>
<div class="line">  <span class="keywordflow">if</span> (key == 0)</div>
  <a class="code hl_function" href="namespacettg.html#a8f6699133cf34d99b17a41af9834a272">ttg::sendv</a>&lt;0&gt;(input + 1.0, out);<div class="line">  <span class="keywordflow">else</span></div>
  <a class="code hl_function" href="namespacettg.html#a8f6699133cf34d99b17a41af9834a272">ttg::sendv</a>&lt;1&gt;(input + 1.0, out);<div class="line">}</div>
<div class="ttc" id="anamespacettg_html_a8f6699133cf34d99b17a41af9834a272"><div class="ttname"><a href="namespacettg.html#a8f6699133cf34d99b17a41af9834a272">ttg::sendv</a></div><div class="ttdeci">void sendv(valueT &amp;&amp;value, ttg::Out&lt; void, valueT &gt; &amp;t)</div><div class="ttdoc">Sends a value (without an accompanying task id) to the given output terminal.</div><div class="ttdef"><b>Definition</b> <a href="func_8h_source.html#l00180">func.h:180</a></div></div>
</div><!-- fragment --><p> This function defines the behavior of tasks of type B.</p>
<p>This time, tasks of type B have an integer identifier (<code>key</code>), an input value (<code>value</code>), of type <code>double</code>, and two output terminals. Both output terminals have no identifier (keys of type <code>void</code>), and carry a data of type <code>double</code>.</p>
<p>The task sends to different terminals depending on the value of <code>key</code>: tasks with a <code>key</code> of <code>0</code> output on the terminal of index <code>&lt;0&gt;</code>, while tasks with another <code>key</code> output on the terminal of index <code>&lt;1&gt;</code>. They also output different values on these edges.</p>
<p>Because the output terminals do not define a task identifier (their keys are of type <code>void</code>), one cannot use <code><a class="el" href="namespacettg.html#a195eb3c0d9b0118dd7c94c0463840734" title="Sends a task id and a value to the given output terminal.">ttg::send</a></code>, but needs to use <code><a class="el" href="namespacettg.html#a8f6699133cf34d99b17a41af9834a272" title="Sends a value (without an accompanying task id) to the given output terminal.">ttg::sendv</a></code>. <code><a class="el" href="namespacettg.html#a8f6699133cf34d99b17a41af9834a272" title="Sends a value (without an accompanying task id) to the given output terminal.">ttg::sendv</a></code> differs from <code><a class="el" href="namespacettg.html#a195eb3c0d9b0118dd7c94c0463840734" title="Sends a task id and a value to the given output terminal.">ttg::send</a></code> only in the fact that <code><a class="el" href="namespacettg.html#a195eb3c0d9b0118dd7c94c0463840734" title="Sends a task id and a value to the given output terminal.">ttg::send</a></code> requires a key identifier for the destination task, while <code><a class="el" href="namespacettg.html#a8f6699133cf34d99b17a41af9834a272" title="Sends a value (without an accompanying task id) to the given output terminal.">ttg::sendv</a></code> does not.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> c(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;b0, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;b1, std::tuple&lt;&gt; &amp;out) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task C with inputs &quot;</span>, b0, <span class="stringliteral">&quot; from B(0) and &quot;</span>, b1, <span class="stringliteral">&quot; from B(1)&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Tasks of type C are implemented with this function. It's a sink task: no <code><a class="el" href="namespacettg.html#a195eb3c0d9b0118dd7c94c0463840734" title="Sends a task id and a value to the given output terminal.">ttg::send</a></code> are emitted by this task that takes no task identifier, defines no output terminals, and only an input value of type <code>double</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="distributed_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a19c06079af2c21be154b525ff21028d1">ttg::initialize</a>(argc, argv, -1);</div>
<div class="ttc" id="adistributed_8cc_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="distributed_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdef"><b>Definition</b> <a href="distributed_8cc_source.html#l00032">distributed.cc:32</a></div></div>
<div class="ttc" id="anamespacettg_html_a19c06079af2c21be154b525ff21028d1"><div class="ttname"><a href="namespacettg.html#a19c06079af2c21be154b525ff21028d1">ttg::initialize</a></div><div class="ttdeci">void initialize(int argc, char **argv, int num_threads=-1, RestOfArgs &amp;&amp;...)</div></div>
</div><!-- fragment --><p> The code needs to initialize ttg before any other ttg-related calls.</p>
<div class="fragment"><div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;int, double&gt;</a> A_B(<span class="stringliteral">&quot;A-&gt;B&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;void, double&gt;</a> B_C0(<span class="stringliteral">&quot;B-&gt;C0&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;void, double&gt;</a> B_C1(<span class="stringliteral">&quot;B-&gt;C1&quot;</span>);</div>
<div class="ttc" id="aclassttg_1_1_edge_html"><div class="ttname"><a href="classttg_1_1_edge.html">ttg::Edge</a></div><div class="ttdoc">Edge is used to connect In and Out terminals.</div><div class="ttdef"><b>Definition</b> <a href="edge_8h_source.html#l00026">edge.h:26</a></div></div>
</div><!-- fragment --><p> We define 3 edges, to connect the different tasks together.</p>
<p>They have different prototypes: <code>A_B</code> carries an identifier of type <code>int</code> and a value of type <code>double</code>, while <code>B_C0</code> and <code>B_C1</code> carry no identifier (<code>void</code>) and a value of type <code>double</code>.</p>
<p>To help debugging, we give unique meaningful names to these edges in the constructor argument.</p>
<p>We need only three edges, because these edges define connections between the template tasks, not connections between tasks. Their instantiation by <code><a class="el" href="namespacettg.html#a195eb3c0d9b0118dd7c94c0463840734" title="Sends a task id and a value to the given output terminal.">ttg::send</a></code> or <code><a class="el" href="namespacettg.html#a8f6699133cf34d99b17a41af9834a272" title="Sends a value (without an accompanying task id) to the given output terminal.">ttg::sendv</a></code> define the actual edges between tasks.</p>
<p>There are two edges connecting <code>B</code> to <code>C</code> because <code>C</code> has two input terminals, and if we used the same edge between <code>B</code> and <code>C</code>, sending on that edge would trigger <code>C</code> twice.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> wa(ttg::make_tt&lt;void&gt;(a, <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(A_B), <span class="stringliteral">&quot;A&quot;</span>, {}, {<span class="stringliteral">&quot;to B&quot;</span>}));</div>
<div class="line">  <span class="keyword">auto</span> wb(ttg::make_tt(b, <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(A_B), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(B_C0, B_C1), <span class="stringliteral">&quot;B&quot;</span>, {<span class="stringliteral">&quot;from A&quot;</span>}, {<span class="stringliteral">&quot;to 1st input of C&quot;</span>, <span class="stringliteral">&quot;to 2nd input of C&quot;</span>}));</div>
<div class="line">  <span class="keyword">auto</span> wc(ttg::make_tt(c, <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(B_C0, B_C1), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(), <span class="stringliteral">&quot;C&quot;</span>, {<span class="stringliteral">&quot;From B&quot;</span>, <span class="stringliteral">&quot;From B&quot;</span>}, {}));</div>
<div class="ttc" id="anamespacettg_html_afbabcd9802bf1bbdd302e7a612459353"><div class="ttname"><a href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a></div><div class="ttdeci">auto edges(inedgesT &amp;&amp;...args)</div><div class="ttdoc">Make a tuple of Edges to pass to.</div><div class="ttdef"><b>Definition</b> <a href="func_8h_source.html#l00148">func.h:148</a></div></div>
</div><!-- fragment --><p> We now define the three template tasks <code>wa</code>, <code>wb</code>, and <code>wc</code>, using the <code>ttg::make_tt</code> helper.</p>
<p><code>ttg::make_tt</code> takes as parameters the function that implements the task, the list of input edges that are connected to its input terminals, the list of output edges that are connected to its output terminals, the name of the task, the list of names for the input terminals, and the list of names for the output terminals.</p>
<p>These TTs and the edges define the template task graph that will then be instantiated as a DAG of tasks by the execution.</p>
<div class="fragment"><div class="line">  <a class="code hl_function" href="namespacettg.html#ade4672895f07e88909dab1644c69e60a">ttg::make_graph_executable</a>(wa);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (wa-&gt;get_world().rank() == 0) wa-&gt;invoke();</div>
<div class="ttc" id="anamespacettg_html_ade4672895f07e88909dab1644c69e60a"><div class="ttname"><a href="namespacettg.html#ade4672895f07e88909dab1644c69e60a">ttg::make_graph_executable</a></div><div class="ttdeci">std::enable_if_t&lt;(std::is_convertible_v&lt; decltype(*(std::declval&lt; TTBasePtrs &gt;())), TTBase &amp; &gt; &amp;&amp;...), bool &gt; make_graph_executable(TTBasePtrs &amp;&amp;...tts)</div><div class="ttdoc">Make the TTG tts executable. Applies.</div><div class="ttdef"><b>Definition</b> <a href="func_8h_source.html#l00081">func.h:81</a></div></div>
</div><!-- fragment --><p> Before executing the first tasks, the template task graph must be made executable by calling <code><a class="el" href="namespacettg.html#ade4672895f07e88909dab1644c69e60a" title="Make the TTG tts executable. Applies.">ttg::make_graph_executable()</a></code> on each source TT of the graph. This signals to the runtime system that all edges that connect TTs are defined, computes internal state necessary to track all dependencies, and registers active message handles for each template task type.</p>
<p>We need to start the DAG of tasks by invoking the initial tasks with <code><a class="el" href="classttg_1_1_t_t_base.html#a1c8161302cb6f3f8d7d7f80b00a56e03">ttg::TTBase::invoke()</a></code>. In this simple DAG, there is a single initial task, the task A, which runs on rank 0.</p>
<div class="fragment"><div class="line">  <a class="code hl_function" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a>();</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a>(<a class="code hl_function" href="namespacettg.html#a5829b255a41f2e47fa0e27bb5c791824">ttg::get_default_world</a>());</div>
<div class="ttc" id="anamespacettg_html_a1261c57f70c978771f64af07d7f7d7cd"><div class="ttname"><a href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a></div><div class="ttdeci">void execute(ttg::World world)</div><div class="ttdoc">Starts the execution in the given execution context.</div><div class="ttdef"><b>Definition</b> <a href="run_8h_source.html#l00116">run.h:116</a></div></div>
<div class="ttc" id="anamespacettg_html_a5829b255a41f2e47fa0e27bb5c791824"><div class="ttname"><a href="namespacettg.html#a5829b255a41f2e47fa0e27bb5c791824">ttg::get_default_world</a></div><div class="ttdeci">ttg::World &amp; get_default_world()</div><div class="ttdef"><b>Definition</b> <a href="world_8h_source.html#l00081">world.h:81</a></div></div>
<div class="ttc" id="anamespacettg_html_a807bf42719a82b1539603d477aa2a3fd"><div class="ttname"><a href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a></div><div class="ttdeci">void fence(ttg::World world)</div><div class="ttdoc">Returns when all tasks associated with the given execution context have finished on all ranks.</div><div class="ttdef"><b>Definition</b> <a href="run_8h_source.html#l00123">run.h:123</a></div></div>
</div><!-- fragment --><p> We can then start the execution of the DAG of tasks. This will enable the compute-threads in the ttg library, and start instantiating tasks as the execution unfolds.</p>
<p>With <code><a class="el" href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd" title="Returns when all tasks associated with the given execution context have finished on all ranks.">ttg::fence()</a></code>, we wait for the completion of all DAGs started.</p>
<div class="fragment"><div class="line">  <a class="code hl_function" href="namespacettg.html#a96780ef3c553a2f45aa7ea881bdb6490">ttg::finalize</a>();</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacettg_html_a96780ef3c553a2f45aa7ea881bdb6490"><div class="ttname"><a href="namespacettg.html#a96780ef3c553a2f45aa7ea881bdb6490">ttg::finalize</a></div><div class="ttdeci">void finalize()</div><div class="ttdoc">Finalizes the TTG runtime.</div><div class="ttdef"><b>Definition</b> <a href="func_8h_source.html#l00590">func.h:590</a></div></div>
</div><!-- fragment --><p> And finally, we can shut down the ttg library and return from the application.</p>
<p><a class="el" href="simple_8cc-example.html">Full first example</a></p>
<h1><a class="anchor" id="compiling"></a>
Compiling Your First TTG Program</h1>
<p>The recommended way to compile a TTG program is to use CMake.</p>
<p>Below, you will find a minimal CMakeLists.txt file to compile the first example above with both the PaRSEC and the MADNESS driver.</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.19)</div>
<div class="line">project(TTG-Example CXX)</div>
<div class="line"> </div>
<div class="line">find_package(ttg REQUIRED)</div>
<div class="line"> </div>
<div class="line">add_executable(first-parsec first.cc)</div>
<div class="line">target_compile_definitions(first-parsec PRIVATE TTG_USE_PARSEC=1)</div>
<div class="line">target_link_libraries(first-parsec PRIVATE ttg-parsec)</div>
<div class="line"> </div>
<div class="line">add_executable(first-mad first.cc)</div>
<div class="line">target_compile_definitions(first-mad PRIVATE TTG_USE_MADNESS=1)</div>
<div class="line">target_link_libraries(first-mad PRIVATE ttg-mad)</div>
</div><!-- fragment --><p>This CMakeLists.txt uses <code>find_package(ttg)</code> to define the different ttg targets. <code>find_package</code> uses the <code>ttg_DIR</code> CMake variable as a hint where to find configuration files. So, if you installed ttg in <code>/path/to/ttg</code>, you can point <code>find_package</code> to the appropriate directory by calling CMake as follows:</p>
<div class="fragment"><div class="line">cd /path/to/your/builddir</div>
<div class="line">cmake -Dttg_DIR=/path/to/ttg/lib/cmake/ttg /path/to/your/sourcedir</div>
</div><!-- fragment --><p><code>find_package(ttg)</code> defines the following CMake targets:</p><ul>
<li><code>ttg-parsec</code>: the PaRSEC backend for TTG</li>
<li><code>ttg-mad</code>: the MADNESS backend for TTG</li>
</ul>
<p>When source code <code>#include &lt;ttg.h&gt;</code>, it needs to define which backend it uses. In this example, we do that from the command line, by adding the compile-definition <code>TTG_USE_PARSEC=1</code> or <code>TTG_USE_MADNESS=1</code>.</p>
<p>It is then sufficient to tell CMake that the executable depends on the corresponding TTG target to add the appropriate include path and link commands.</p>
<h1><a class="anchor" id="datadependent"></a>
Data Dependent Program</h1>
<p>We now extend the first example to illustrate a data-dependent application behavior. Consider now that the tasks of type C can dynamically decide to iterate over the simple DAG of tasks before, depending on the values received as input.</p>
<p>To make the example simple, we will simply define a threshold: if the data sent by B(0) plus the data sent by B(1) is lower than this threshold, then the DAG should be iterated, otherwise the application is completed.</p>
<p>One way of representing this behavior is denoted by the graph below:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_iterative.svg" width="623" height="178"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
Iterative diamond DAG</div>
</div>
<p>First, because each task in the DAG needs to be uniquely identified, and there are potentially many tasks of type A or C, tasks of these kinds now need to get an identifier. Second, tasks of type B are not only identified by 0 or 1, but also need another identifier that denotes to which task of A or C it is connected. We extend the identifier type of B to <code>Key2</code>, which is a <code>std::pair&lt;int, int&gt;</code> to do this simply.</p>
<p>Second, the function that implements the task for C needs to decide dynamically if it continues iterating or not. This is done by conditionally calling <code><a class="el" href="namespacettg.html#a195eb3c0d9b0118dd7c94c0463840734" title="Sends a task id and a value to the given output terminal.">ttg::send</a></code> in this function. If the function does not call <code><a class="el" href="namespacettg.html#a195eb3c0d9b0118dd7c94c0463840734" title="Sends a task id and a value to the given output terminal.">ttg::send</a></code>, then the no more task is discovered, and the whole operation will complete.</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ttg.h&gt;</span></div>
</div><!-- fragment --><p> The inclusion of the <code><a class="el" href="serialization_2std_2pair_8h.html">ttg/serialization/std/pair.h</a></code> file is necessary to import the serialization mechanisms for the task identifiers of tasks of type A or C.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a> = 100.0;</div>
<div class="ttc" id="adistributed_8cc_html_a1d82d181e6f77a3479faa6152c83b438"><div class="ttname"><a href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a></div><div class="ttdeci">const double threshold</div><div class="ttdef"><b>Definition</b> <a href="distributed_8cc_source.html#l00006">distributed.cc:6</a></div></div>
</div><!-- fragment --><p> We define the threshold as a globally visible constant.</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a> = std::pair&lt;int, int&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacestd.html">std</a> {</div>
<div class="line">  std::ostream &amp;<a class="code hl_function" href="namespacestd.html#a23678c41a80c407b186771df978f2a24">operator&lt;&lt;</a>(std::ostream &amp;os, <span class="keyword">const</span> <a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a> &amp;key) {</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;{&quot;</span> &lt;&lt; std::get&lt;0&gt;(key) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::get&lt;1&gt;(key) &lt;&lt; <span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> os;</div>
<div class="line">  }</div>
<div class="line">}  <span class="comment">// namespace std</span></div>
<div class="ttc" id="adistributed_8cc_html_a4ed3c6c3b234257403b35824408bc652"><div class="ttname"><a href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a></div><div class="ttdeci">std::pair&lt; int, int &gt; Key2</div><div class="ttdef"><b>Definition</b> <a href="distributed_8cc_source.html#l00007">distributed.cc:7</a></div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
<div class="ttc" id="anamespacestd_html_a23678c41a80c407b186771df978f2a24"><div class="ttname"><a href="namespacestd.html#a23678c41a80c407b186771df978f2a24">std::operator&lt;&lt;</a></div><div class="ttdeci">std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, ttg::device::Device device)</div><div class="ttdef"><b>Definition</b> <a href="device_2device_8h_source.html#l00084">device.h:84</a></div></div>
</div><!-- fragment --><p> We define the key type as a <code>std::pair&lt;int, int&gt;</code>, and extend the <code>std::operator&lt;&lt;</code> to printout an object of type <code>Key2</code></p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> a(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;k, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;input, std::tuple&lt;<a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;Key2, double&gt;</a>&gt; &amp;out) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task A(&quot;</span>, k, <span class="stringliteral">&quot;)&quot;</span>);</div>
 <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a> &lt;0&gt;(<a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a>{k, 0}, 1.0 + input, out);<div class="line"> <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a> &lt;0&gt;(<a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a>{k, 1}, 2.0 + input, out);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Tasks of type A now take an integer key, and an input value; the output is modified to take a <code>Key2</code> (as tasks of type B have keys of type <code>Key2</code>).</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> b(<span class="keyword">const</span> <a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a> &amp;key, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;input, std::tuple&lt;<a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;int, double&gt;</a>, <a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;int, double&gt;</a>&gt; &amp;out) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task B(&quot;</span>, key, <span class="stringliteral">&quot;) with input data &quot;</span>, input);</div>
<div class="line">  <span class="keywordflow">if</span> (std::get&lt;1&gt;(key) == 0)</div>
 <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a> &lt;0&gt;(std::get&lt;0&gt;(key), input + 1.0, out);<div class="line">  <span class="keywordflow">else</span></div>
 <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a> &lt;1&gt;(std::get&lt;0&gt;(key), input + 1.0, out);<div class="line">}</div>
</div><!-- fragment --><p> Tasks of type B now take a key of type <code>Key2</code>, and the output is modified to take an integer key. We then use <code><a class="el" href="namespacettg.html#a195eb3c0d9b0118dd7c94c0463840734" title="Sends a task id and a value to the given output terminal.">ttg::send</a></code> instead of <code><a class="el" href="namespacettg.html#a8f6699133cf34d99b17a41af9834a272" title="Sends a value (without an accompanying task id) to the given output terminal.">ttg::sendv</a></code>, because <code><a class="el" href="namespacettg.html#a8f6699133cf34d99b17a41af9834a272" title="Sends a value (without an accompanying task id) to the given output terminal.">ttg::sendv</a></code> is only used to send to a task that does not have a key identifier.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> c(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;k, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;b0, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;b1, std::tuple&lt;<a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;int, double&gt;</a>&gt; &amp;out) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task C(&quot;</span>, k, <span class="stringliteral">&quot;) with inputs &quot;</span>, b0, <span class="stringliteral">&quot; from B(&quot;</span>, k, <span class="stringliteral">&quot; 0) and &quot;</span>, b1, <span class="stringliteral">&quot; from B(&quot;</span>, k, <span class="stringliteral">&quot; 1)&quot;</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (b0 + b1 &lt; <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a>) {</div>
<div class="line">    <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;  &quot;</span>, b0, <span class="stringliteral">&quot;+&quot;</span>, b1, <span class="stringliteral">&quot;&lt;&quot;</span>, <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a>, <span class="stringliteral">&quot; so continuing to iterate&quot;</span>);</div>
 <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a> &lt;0&gt;(k + 1, b0 + b1, out);<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;  &quot;</span>, b0, <span class="stringliteral">&quot;+&quot;</span>, b1, <span class="stringliteral">&quot;&gt;=&quot;</span>, <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a>, <span class="stringliteral">&quot; so stopping the iterations&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Tasks of type C are modified the same way, and the function that implements the task holds the dynamic decision to continue in the DAG or not.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="distributed_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a19c06079af2c21be154b525ff21028d1">ttg::initialize</a>(argc, argv, -1);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;Key2, double&gt;</a> A_B(<span class="stringliteral">&quot;A(k)-&gt;B(k)&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;int, double&gt;</a> B_C0(<span class="stringliteral">&quot;B(k)-&gt;C0(k)&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;int, double&gt;</a> B_C1(<span class="stringliteral">&quot;B(k)-&gt;C1(k)&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;int, double&gt;</a> C_A(<span class="stringliteral">&quot;C(k)-&gt;A(k)&quot;</span>);</div>
</div><!-- fragment --><p> We update the edges types to reflect the new tasks prototypes, and add a new edge, that loops from C(k) to A(k+1) (note that the value of the key is decided in the function itself, this has no impact on this part of the code).</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> wa(ttg::make_tt(a, <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(C_A), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(A_B), <span class="stringliteral">&quot;A&quot;</span>, {<span class="stringliteral">&quot;from C&quot;</span>}, {<span class="stringliteral">&quot;to B&quot;</span>}));</div>
<div class="line">  <span class="keyword">auto</span> wb(ttg::make_tt(b, <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(A_B), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(B_C0, B_C1), <span class="stringliteral">&quot;B&quot;</span>, {<span class="stringliteral">&quot;from A&quot;</span>},</div>
<div class="line">                       {<span class="stringliteral">&quot;to 1st input of C&quot;</span>, <span class="stringliteral">&quot;to 2nd input of C&quot;</span>}));</div>
<div class="line">  <span class="keyword">auto</span> wc(ttg::make_tt(c, <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(B_C0, B_C1), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(C_A), <span class="stringliteral">&quot;C&quot;</span>, {<span class="stringliteral">&quot;From B&quot;</span>, <span class="stringliteral">&quot;From B&quot;</span>}, {<span class="stringliteral">&quot;to A&quot;</span>}));</div>
</div><!-- fragment --><p> The <code>ttg::make_tt</code> calls are also updated to reflect the new task prototypes, and include the edge from C(k) to A(k+1).</p>
<div class="fragment"><div class="line">  <a class="code hl_function" href="namespacettg.html#ade4672895f07e88909dab1644c69e60a">ttg::make_graph_executable</a>(wa);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (wa-&gt;get_world().rank() == 0) wa-&gt;invoke(0, 0.0);</div>
</div><!-- fragment --><p> When invoking A(0, 0.0), one needs to provide the key for the task and the input value for each input that A now defines.</p>
<div class="fragment"><div class="line">  <a class="code hl_function" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a>();</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a>(<a class="code hl_function" href="namespacettg.html#a5829b255a41f2e47fa0e27bb5c791824">ttg::get_default_world</a>());</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a96780ef3c553a2f45aa7ea881bdb6490">ttg::finalize</a>();</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="iterative_8cc-example.html">Full iterative diamond example</a></p>
<h1><a class="anchor" id="streamingterminals"></a>
Streaming Terminals</h1>
<p>Now, consider that for a given k, there can be a large amount of tasks of type B, and that the number of such tasks depends on some computation. This means that the input of tasks of type C is not fixed, but variable.</p>
<p>To express such construct, it is possible to do it by building a sub-DAG of tasks that combine the outputs of the different tasks of class B before passing the combination to task C.</p>
<p>TTG provides a more synthetic construct to do so easily: the streaming terminals.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_reducing.svg" width="703" height="340"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
DAG of the iterative diamond of arbitary width</div>
</div>
<p>The begining of the program remains identical to the iterative case above: we still use a <code>std::pair&lt;int, int&gt;</code> that we alias as <code>Key2</code> to define the task identifiers of tasks of class B, and we use the standard serialization provided by TTG for those.</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ttg.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="serialization_2std_2pair_8h.html">ttg/serialization/std/pair.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="util_2hash_2std_2pair_8h.html">ttg/util/hash/std/pair.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a> = 100.0;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a> = std::pair&lt;int, int&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacestd.html">std</a> {</div>
<div class="line">  std::ostream &amp;<a class="code hl_function" href="namespacestd.html#a23678c41a80c407b186771df978f2a24">operator&lt;&lt;</a>(std::ostream &amp;os, <span class="keyword">const</span> <a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a> &amp;key) {</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;{&quot;</span> &lt;&lt; std::get&lt;0&gt;(key) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::get&lt;1&gt;(key) &lt;&lt; <span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> os;</div>
<div class="line">  }</div>
<div class="line">}  <span class="comment">// namespace std</span></div>
<div class="ttc" id="aserialization_2std_2pair_8h_html"><div class="ttname"><a href="serialization_2std_2pair_8h.html">pair.h</a></div></div>
<div class="ttc" id="autil_2hash_2std_2pair_8h_html"><div class="ttname"><a href="util_2hash_2std_2pair_8h.html">pair.h</a></div></div>
</div><!-- fragment --><p> The code for tasks of type A will be inlined as a lambda function, because it needs to access other parts of the DAG that need to be defined before. The code for tasks of type B becomes simpler: we always send the updated input that tasks of type B receive to the single input terminal of tasks of task C, so we don't need to differentiate between the keys to decide on which output terminal to provide the data.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> b(<span class="keyword">const</span> <a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a> &amp;key, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;input, std::tuple&lt;<a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;int, double&gt;</a>&gt; &amp;out) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task B(&quot;</span>, key, <span class="stringliteral">&quot;) with input data &quot;</span>, input);</div>
 <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a> &lt;0&gt;(std::get&lt;0&gt;(key), input + 1.0, out);<div class="line">}</div>
</div><!-- fragment --><p> Tasks of type C have been simplified too: they now take a single input, and it's the input terminal that will do the sum operation.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> c(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;k, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;sum, std::tuple&lt;<a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;int, double&gt;</a>&gt; &amp;out) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task C(&quot;</span>, k, <span class="stringliteral">&quot;) with input &quot;</span>, sum);</div>
<div class="line">  <span class="keywordflow">if</span> (sum &lt; <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a>) {</div>
<div class="line">    <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;  &quot;</span>, sum, <span class="stringliteral">&quot;&lt;&quot;</span>, <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a>, <span class="stringliteral">&quot; so continuing to iterate&quot;</span>);</div>
 <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a> &lt;0&gt;(k + 1, sum, out);<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;  &quot;</span>, sum, <span class="stringliteral">&quot;&gt;=&quot;</span>, <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a>, <span class="stringliteral">&quot; so stopping the iterations&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> The main program that builds the DAG starts similarly to the simple iterative diamond example. Edge types have been simplified, because there is less unique edges (but edges of type <code>C_A</code> will be extended to include the streaming capability).</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="distributed_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a19c06079af2c21be154b525ff21028d1">ttg::initialize</a>(argc, argv, -1);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;Key2, double&gt;</a> A_B(<span class="stringliteral">&quot;A(k)-&gt;B(k, i)&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;int, double&gt;</a> B_C(<span class="stringliteral">&quot;B(k, i)-&gt;C(k)&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;int, double&gt;</a> C_A(<span class="stringliteral">&quot;C(k)-&gt;A(k)&quot;</span>);</div>
</div><!-- fragment --><p> Tasks of type C are defined first, because we need to expose those to the code of tasks of type A.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> wc(ttg::make_tt(c, <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(B_C), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(C_A), <span class="stringliteral">&quot;C&quot;</span>, {<span class="stringliteral">&quot;From B&quot;</span>}, {<span class="stringliteral">&quot;to A&quot;</span>}));</div>
</div><!-- fragment --><p> Now, we define the input reducer function to apply to the input terminal 0 of tasks of type C. The <code>set_input_reducer</code> function takes two references to elements of the appropriate type, <code>a</code> and <code>b</code>. The operation goal is to aggregate the values as they are sent to the input terminal. The first time a data is sent to this input terminal, it is copied onto the current aggregated value. Every other data sent to the same input terminal (and for the same destination task) is reduced into the aggregator value via this lambda. <code>a</code> is a reference to the (mutable) aggregator value, while <code>b</code> is a reference to the (constant) value to add.</p>
<p>Here, the function we define simply adds the value of <code>b</code> to <code>a</code>.</p>
<div class="fragment"><div class="line"> wc-&gt;set_input_reducer &lt;0&gt;(</div>
</div><!-- fragment --><p> We can now define the tasks of type A. Instead of passing the function to call, we define it in a lambda expression, which allows us to capture the TT of type C (<code>wc</code>). The prototype of this lambda is the one expected for tasks of the A. After displaying its name, the task calls <code>set_argstream_size</code> on the first input (<code>&lt;0&gt;</code>) of <code>wc</code>. This function takes two arguments: a task identifier (<code>k</code>), and the number of elements that are expected as input of the streaming terminal <code>&lt;0&gt;</code>. That counter can be data depndent, in this case we set it to <code>k+1</code>.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> wa(ttg::make_tt(</div>
<div class="line">      [&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;k, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;input, std::tuple&lt;<a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;Key2, double&gt;</a>&gt; &amp;out) {</div>
<div class="line">        <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task A(&quot;</span>, k, <span class="stringliteral">&quot;)&quot;</span>);</div>
<div class="line">        wc-&gt;set_argstream_size&lt;0&gt;(k, k + 1);</div>
</div><!-- fragment --><p> The task can then create as many tasks of type B as is needed, and since each task of type B will output their value into the streaming terminal of the corresponding C, we instantiate <code>k+1</code> tasks of type B by sending them input data.</p>
<p>The other parameters are the usual parameters of <code>ttg::make_tt</code>.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k + 1; i++) {</div>
<div class="line">          <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a> &lt;0&gt;(<a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a>{k, i}, 1.0 + k + input, out);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line">      <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(C_A), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(A_B), <span class="stringliteral">&quot;A&quot;</span>, {<span class="stringliteral">&quot;from C&quot;</span>}, {<span class="stringliteral">&quot;to B&quot;</span>}));</div>
</div><!-- fragment --><p> Tasks of type B are created according to the new prototype, and the rest of the code is unchanged.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> wb(ttg::make_tt(b, <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(A_B), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(B_C), <span class="stringliteral">&quot;B&quot;</span>, {<span class="stringliteral">&quot;from A&quot;</span>}, {<span class="stringliteral">&quot;to C&quot;</span>}));</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#ade4672895f07e88909dab1644c69e60a">ttg::make_graph_executable</a>(wa);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (wa-&gt;get_world().rank() == 0) wa-&gt;invoke(0, 0.0);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a>();</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a>(<a class="code hl_function" href="namespacettg.html#a5829b255a41f2e47fa0e27bb5c791824">ttg::get_default_world</a>());</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a96780ef3c553a2f45aa7ea881bdb6490">ttg::finalize</a>();</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="reducing_8cc-example.html">Full iterative diamond of arbitrary width example</a></p>
<h1><a class="anchor" id="distributedcomputing"></a>
Distributed Computing</h1>
<p>Any TTG program is a parallel application. In the current backends, TTG applications are also MPI applications. Tasks are distributed between the MPI ranks following a process keymap. The default process keymap hashes the task identifiers and distributes the hashes in a round-robin way. The user can control the task distribution by setting a user-defined keymap for Task Templates.</p>
<p>In the iterative diamond of arbitrary width, we can easily provide a suitable keymap by pinning tasks of type A and C (which are the first and last task of each diamond) onto the rank 0, while distributing the tasks of type B between the ranks using the second element in the key of those tasks.</p>
<p>This gives the code below, almost identical to the previous example, except for the keymap definition, and displaying on which rank each task executes.</p>
<div class="fragment"><div class="line"><span class="comment">// SPDX-License-Identifier: BSD-3-Clause</span></div>
<div class="line"><span class="preprocessor">#include &lt;ttg.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="serialization_2std_2pair_8h.html">ttg/serialization/std/pair.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="util_2hash_2std_2pair_8h.html">ttg/util/hash/std/pair.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a> = 100.0;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a> = std::pair&lt;int, int&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacestd.html">std</a> {</div>
<div class="line">  std::ostream &amp;<a class="code hl_function" href="namespacestd.html#a23678c41a80c407b186771df978f2a24">operator&lt;&lt;</a>(std::ostream &amp;os, <span class="keyword">const</span> <a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a> &amp;key) {</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;{&quot;</span> &lt;&lt; std::get&lt;0&gt;(key) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::get&lt;1&gt;(key) &lt;&lt; <span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> os;</div>
<div class="line">  }</div>
<div class="line">}  <span class="comment">// namespace std</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> b(<span class="keyword">const</span> <a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a> &amp;key, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;input, std::tuple&lt;<a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;int, double&gt;</a>&gt; &amp;out) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task B(&quot;</span>, key, <span class="stringliteral">&quot;) on rank&quot;</span>, <a class="code hl_function" href="namespacettg__parsec.html#ae1b91b1ff1edc3fbc1e7e07d6c659c17">ttg::ttg_default_execution_context</a>().<a class="code hl_function" href="namespacettg.html#ac0ad1dd3b87329e4acf9774df6dc8473">rank</a>(), <span class="stringliteral">&quot;with input data &quot;</span>, input);</div>
  <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a>&lt;0&gt;(std::get&lt;0&gt;(key), input + 1.0, out);<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> c(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;k, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;sum, std::tuple&lt;<a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;int, double&gt;</a>&gt; &amp;out) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task C(&quot;</span>, k, <span class="stringliteral">&quot;) on rank&quot;</span>, <a class="code hl_function" href="namespacettg__parsec.html#ae1b91b1ff1edc3fbc1e7e07d6c659c17">ttg::ttg_default_execution_context</a>().<a class="code hl_function" href="namespacettg.html#ac0ad1dd3b87329e4acf9774df6dc8473">rank</a>(), <span class="stringliteral">&quot;with input &quot;</span>, sum);</div>
<div class="line">  <span class="keywordflow">if</span> (sum &lt; <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a>) {</div>
<div class="line">    <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;  &quot;</span>, sum, <span class="stringliteral">&quot;&lt;&quot;</span>, <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a>, <span class="stringliteral">&quot; so continuing to iterate&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a>&lt;0&gt;(k + 1, sum, out);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;  &quot;</span>, sum, <span class="stringliteral">&quot;&gt;=&quot;</span>, <a class="code hl_variable" href="distributed_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a>, <span class="stringliteral">&quot; so stopping the iterations&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="distributed_8cc.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a19c06079af2c21be154b525ff21028d1">ttg::initialize</a>(argc, argv, -1);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;Key2, double&gt;</a> A_B(<span class="stringliteral">&quot;A(k)-&gt;B(k, i)&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;int, double&gt;</a> B_C(<span class="stringliteral">&quot;B(k, i)-&gt;C(k)&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classttg_1_1_edge.html">ttg::Edge&lt;int, double&gt;</a> C_A(<span class="stringliteral">&quot;C(k)-&gt;A(k)&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> wc(ttg::make_tt(c, <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(B_C), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(C_A), <span class="stringliteral">&quot;C&quot;</span>, {<span class="stringliteral">&quot;From B&quot;</span>}, {<span class="stringliteral">&quot;to A&quot;</span>}));</div>
<div class="line"> </div>
wc-&gt;set_input_reducer&lt;0&gt;([](<span class="keywordtype">double</span> &amp;a, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;b) { a += b; });<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> wa(ttg::make_tt([&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;k, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;input, std::tuple&lt;<a class="code hl_class" href="classttg_1_1_out.html">ttg::Out&lt;Key2, double&gt;</a>&gt; &amp;out) {</div>
<div class="line">      <a class="code hl_function" href="namespacettg.html#aa3510e128b769afb53720d24fa83fb97">ttg::print</a>(<span class="stringliteral">&quot;Called task A(&quot;</span>, k, <span class="stringliteral">&quot;) on rank&quot;</span>, <a class="code hl_function" href="namespacettg__parsec.html#ae1b91b1ff1edc3fbc1e7e07d6c659c17">ttg::ttg_default_execution_context</a>().<a class="code hl_function" href="namespacettg.html#ac0ad1dd3b87329e4acf9774df6dc8473">rank</a>());</div>
<div class="line">      wc-&gt;set_argstream_size&lt;0&gt;(k, k+1);</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; k+1; i++) {</div>
<div class="line">          <a class="code hl_function" href="namespacettg.html#a1b23b6cea5360627c9f1e1e9f421bcf3">ttg::send</a>&lt;0&gt;(<a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a>{k, i}, 1.0 + k + input, out);</div>
<div class="line">      }</div>
<div class="line">    }, <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(C_A), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(A_B), <span class="stringliteral">&quot;A&quot;</span>, {<span class="stringliteral">&quot;from C&quot;</span>}, {<span class="stringliteral">&quot;to B&quot;</span>}));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> wb(ttg::make_tt(b, <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(A_B), <a class="code hl_function" href="namespacettg.html#afbabcd9802bf1bbdd302e7a612459353">ttg::edges</a>(B_C), <span class="stringliteral">&quot;B&quot;</span>, {<span class="stringliteral">&quot;from A&quot;</span>}, {<span class="stringliteral">&quot;to C&quot;</span>}));</div>
<div class="line"> </div>
<div class="line">  wa-&gt;set_keymap([&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;k) { <span class="keywordflow">return</span> 0; });</div>
<div class="line">  wb-&gt;set_keymap([&amp;](<span class="keyword">const</span> <a class="code hl_typedef" href="distributed_8cc.html#a4ed3c6c3b234257403b35824408bc652">Key2</a> &amp;k) { <span class="keywordflow">return</span> std::get&lt;1&gt;(k) % wb-&gt;get_world().size(); });</div>
<div class="line">  wc-&gt;set_keymap([&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;k) { <span class="keywordflow">return</span> 0; });</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#ade4672895f07e88909dab1644c69e60a">ttg::make_graph_executable</a>(wa);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (wa-&gt;get_world().rank() == 0) wa-&gt;invoke(0, 0.0);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a1261c57f70c978771f64af07d7f7d7cd">ttg::execute</a>();</div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a807bf42719a82b1539603d477aa2a3fd">ttg::fence</a>(<a class="code hl_function" href="namespacettg.html#a5829b255a41f2e47fa0e27bb5c791824">ttg::get_default_world</a>());</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacettg.html#a96780ef3c553a2f45aa7ea881bdb6490">ttg::finalize</a>();</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="anamespacettg__parsec_html_ae1b91b1ff1edc3fbc1e7e07d6c659c17"><div class="ttname"><a href="namespacettg__parsec.html#ae1b91b1ff1edc3fbc1e7e07d6c659c17">ttg_parsec::ttg_default_execution_context</a></div><div class="ttdeci">ttg::World ttg_default_execution_context()</div><div class="ttdef"><b>Definition</b> <a href="ttg_2parsec_2ttg_8h_source.html#l01137">ttg.h:1137</a></div></div>
<div class="ttc" id="anamespacettg_html_ac0ad1dd3b87329e4acf9774df6dc8473"><div class="ttname"><a href="namespacettg.html#ac0ad1dd3b87329e4acf9774df6dc8473">ttg::rank</a></div><div class="ttdeci">int rank(World world=default_execution_context())</div><div class="ttdef"><b>Definition</b> <a href="run_8h_source.html#l00127">run.h:127</a></div></div>
</div><!-- fragment --><p><a class="el" href="distributed_8cc-example.html">Full iterative diamond of arbitrary width example with user-defined keymap</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Tue Feb 10 2026 20:41:12 for <a href="https://https://github.com/ValeevGroup/tiledarray/">ttg</a>
    1.0.0 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.8
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
